\documentclass{lmcs}
\pdfoutput=1

\usepackage{enumerate}
\usepackage[colorlinks=true]{hyperref}
\usepackage{amssymb}
\usepackage{xcolor,latexsym,amsmath,extarrows,alltt}
\usepackage{xspace}
\usepackage{booktabs}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{stmaryrd}
\usepackage{microtype}

\theoremstyle{theorem}\newtheorem{theorem}{Theorem}
\theoremstyle{theorem}\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{theorem}\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}\newtheorem{definition}[theorem]{Definition}
\theoremstyle{definition}\newtheorem{example}[theorem]{Example}

\newcommand{\N}{\mathbb{N}}
\newcommand{\F}{\mathcal{F}}
\newcommand{\thF}{\mathcal{F}_{\mathtt{theory}}}
\newcommand{\thFext}{\mathcal{F}_{\mathtt{theory}}^{\mathtt{extd}}}
\newcommand{\thSigma}{\Sigma_{\mathtt{theory}}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\thV}{\mathcal{V}_{\mathtt{theory}}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\MM}{\mathbb{M}}
\newcommand{\thM}{\mathcal{M}_{\mathtt{theory}}}
\newcommand{\Vfree}{\mathcal{V}_{\mathit{nonb}}}
\newcommand{\thVfree}{\mathcal{V}_{\mathit{nonb},\mathtt{theory}}}
\newcommand{\Vbound}{\mathcal{V}_{\mathit{binder}}}
\newcommand{\thVbound}{\mathcal{V}_{\mathit{binder},\mathtt{theory}}}
\newcommand{\Sorts}{\mathcal{S}}
\newcommand{\thSorts}{\mathcal{S}_{\mathtt{theory}}}
\newcommand{\Types}{\mathcal{Y}}
\newcommand{\thTypes}{\mathcal{Y}_{\mathtt{theory}}}
\newcommand{\Terms}{\mathcal{T}}
\newcommand{\MTerms}{\mathcal{B}}
\newcommand{\ATerms}{\mathcal{T}_{\mathcal{A}}}
\newcommand{\FOTerms}{\mathcal{T}_{\mathcal{FO}}}
\newcommand{\Rules}{\mathcal{R}}
\newcommand{\Rulescalc}{\mathcal{R}_{\mathtt{calc}}}
\newcommand{\atrs}{\mathbb{R}}
\newcommand{\termsset}{\mathbb{T}}
\newcommand{\FV}{\mathit{FV}}
\newcommand{\FMV}{\mathit{MV}}
\newcommand{\BV}{\mathit{BV}}
\newcommand{\Positions}{\mathsf{Pos}}
\newcommand{\Pairs}{\mathit{Pairs}}
\newcommand{\I}{\mathcal{I}}
\newcommand{\J}{\mathcal{J}}
\newcommand{\Val}{\mathcal{V}\!\mathit{al}}
\newcommand{\Reps}[1]{\mathcal{R}\!\mathit{ep}_{#1}}
\newcommand{\LVar}[1]{\mathit{LVar}(#1)}
\newcommand{\TLVar}[1]{\mathit{TVar}(#1)}

\newcommand{\domain}{\mathtt{dom}}
\newcommand{\order}{\mathit{order}}

\newcommand{\asort}{\iota}
\newcommand{\bsort}{\kappa}
\newcommand{\atype}{\sigma}
\newcommand{\btype}{\tau}
\newcommand{\ctype}{\pi}
\newcommand{\dtype}{\alpha}
\newcommand{\identifier}[1]{\mathtt{#1}}
\newcommand{\afun}{\identifier{f}}
\newcommand{\bfun}{\identifier{g}}
\newcommand{\cfun}{\identifier{h}}
\newcommand{\aconstructor}{\identifier{c}}
\newcommand{\bconstructor}{\identifier{d}}
\newcommand{\avalue}{\identifier{v}}
\newcommand{\bvalue}{\identifier{w}}
\newcommand{\avar}{x}
\newcommand{\bvar}{y}
\newcommand{\cvar}{z}
\newcommand{\Avar}{X}
\newcommand{\Bvar}{Y}
\newcommand{\Cvar}{Z}
\newcommand{\AFvar}{F}
\newcommand{\BFvar}{G}
\newcommand{\CFvar}{H}
\newcommand{\ameta}{F}
\newcommand{\bmeta}{G}
\newcommand{\cmeta}{Z}

\newcommand{\clause}[1]{\textbf{#1}}

\newcommand{\abs}[2]{\lambda #1.#2}
\newcommand{\meta}[2]{#1\langle#2\rangle}
\newcommand{\superapply}{\mathtt{superapply}}
\newcommand{\tuple}[2]{\llparenthesis #1,\dots,#2 \rrparenthesis}
\newcommand{\tuplelong}[1]{\llparenthesis #1 \rrparenthesis}
\newcommand{\product}[2]{\llparenthesis #1,\dots,#2 \rrparenthesis}
\newcommand{\pair}[2]{\llparenthesis #1,#2 \rrparenthesis}
\newcommand{\triple}[3]{\llparenthesis #1,#2,#3 \rrparenthesis}

\newcommand{\arity}{\mathit{arity}}
\newcommand{\head}{\mathsf{head}}
\newcommand{\arrtype}{\Rightarrow}
\newcommand{\arrz}{\Rightarrow}
\newcommand{\arr}[1]{\arrz_{#1}}
\newcommand{\arrr}[1]{\arr{#1}^*}
\newcommand{\subtermeq}{\unlhd}
\newcommand{\headsubtermeq}{\unlhd_{\bullet}}
\newcommand{\supterm}{\rhd}
\newcommand{\suptermeq}{\unrhd}
\newcommand{\interpret}[1]{\llbracket #1 \rrbracket}

\newcommand{\symb}[1]{\mathtt{#1}}

\newcommand{\nul}{\symb{0}}
\newcommand{\one}{\symb{1}}
\newcommand{\nil}{\symb{nil}}
\newcommand{\cons}{\symb{cons}}
\newcommand{\strue}{\symb{true}}
\newcommand{\sfalse}{\symb{false}}
\newcommand{\suc}{\symb{s}}
\newcommand{\map}{\symb{map}}
\newcommand{\bool}{\symb{Bool}}
\newcommand{\tint}{\symb{Int}}
\newcommand{\tstring}{\symb{String}}
\newcommand{\nat}{\symb{nat}}
\newcommand{\lijst}{\symb{list}}
\newcommand{\unitsort}{\mathtt{o}}

\newcommand{\cora}{\textsf{CORA}\xspace}
\newcommand{\charlie}{\textsf{Charlie}\xspace}

\newcommand{\secshort}{\S}
\newcommand{\myparagraph}[1]{\paragraph{\textbf{#1.}}}

\setlength{\parindent}{0pt}
\setlength{\parskip}{\bigskipamount}
\setlist[itemize]{topsep=-\bigskipamount}

\newcommand{\mysubsection}[1]{\vspace{-12pt}\subsubsection{#1}}

\begin{document}

\title{Constrained Higher-order Analysis Rewriting LIbrary: formalism}
\author{Cynthia Kop}
\address{Department of Software Science, Radboud University Nijmegen}
\email{C.Kop@cs.ru.nl}

\maketitle

\begin{abstract}
\cora\ is a tool meant to analyse constrained term rewriting systems, both
first-order and higher-order.
The core library code \charlie\ provides functionality to represent
higher-order term rewriting systems (with or without theories and constraints).
This document explains the underlying formalism.
\end{abstract}

\section{Types}\label{sec:types}

\subsection{Main definition}

We fix a non-empty set $\Sorts$ of \emph{sorts} and define the set $\Types$ of
\emph{types} inductively:
\begin{itemize}
\item all elements of $\Sorts$ are types (also called \emph{base types});
\item if $\atype,\btype \in \Types$ then $\atype \arrtype \btype$ is also a type
  (called an \emph{arrow type});
\item if $\atype_1,\dots,\atype_n \in \Types$ with $n \geq 2$ then
  $\product{\atype_1}{\atype_n}$ is also a type (called a \emph{product type}).
\end{itemize}
The arrow operator $\arrtype$ is right-associative, so all types can be denoted
in a form $\atype_1 \arrtype \dots \arrtype \atype_m \arrtype \asort$ with
$\asort$ a base type or product type; we say the \emph{arity} of this type is
$m$, and the \emph{output type} is $\asort$.

\medskip
Type equality is literal equality (i.e., $\atype_1 \arrtype \btype_1$ is equal
to $\atype_2 \arrtype \btype_2$ iff $\atype_1 = \atype_2$ and $\btype_1 =
\btype_2$, and $\product{\atype_1}{\atype_n}$ is equal to
$\product{\btype_1}{\btype_m}$ if $n = m$ and each $\atype_i = \btype_i$).
We do \emph{not} flatten product types; e.g.,
$\pair{\atype}{\pair{\btype}{\ctype}} \neq \triple{\atype}{\btype}{\ctype}$.

\medskip
\emph{Remark.} We do not impose limitations on the set of sorts, other than that
it is non-empty.  In particular, $\Sorts$ is absolutely allowed to be infinite.
In traditional (unsorted) rewriting, there is only one sort, i.e., $\Sorts =
\{\unitsort\}$.

\subsection{Type order}

The \emph{order} of a type is recursively defined as follows:
\begin{itemize}
\item for $\asort \in \Sorts$: $\order(\asort) = 0$;
\item for arrow types: $\order(\atype \arrtype \btype) = \max(\order(\atype) +
  1,\order(\btype))$.
\item for product types: $\order(\product{\atype_1}{\atype_n}) =
  \max(\order(\atype_1),\dots,\order(\atype_n))$
\end{itemize}

\subsection{Theory types}

We additionally fix a set $\thSorts \subseteq \Sorts$ of \emph{theory sorts},
and define a \emph{theory type} as any type which only uses theory sorts; that
is, a type generated by the grammar:
\[
\thTypes ::= \thSorts \mid \thTypes \arrtype \thTypes \mid
  \product{\thTypes}{\thTypes}
\]

\subsection*{In \charlie}
The following classes are the most relevant:

\begin{itemize}
\item The class \texttt{charlie.types.Type} represents types.
\item Types can be constructed using \texttt{charlie.types.TypeFactory}.
\item All types are immutable, so can be copied around as needed.
\item Types can be printed using \texttt{charlie.types.TypePrinter} or any class
  inheriting it.
  (The in-built \texttt{toString()} is meant for debugging and unit testing, and
  should typically not be used when printing to users.)
\end{itemize}

\emph{For now}, \charlie\ supports three theory sorts: $\tint$, $\bool$ and
$\tstring$ (all of which can be created through the TypeFactory).  Additional
theory sorts -- or support for user-defined theory sorts -- may be added in the
future.

The sort $\unitsort$ used for traditional (unsorted) term rewriting is also
found in the TypeFactory (this is \texttt{TypeFactory.defaultSort}).

\section{Signatures}

We fix a set $\F$ of \emph{function symbols}, also called the \emph{alphabet};
each function symbol is a \emph{typed constant}. Notation: $\afun \in \F$ or
$(\afun :: \atype) \in \F$ if we wish to explicitly refer to the type (but the
type should be considered implicit in the symbol).
Function symbols will generally be referred to as $\afun,\bfun,\cfun$ or using
more suggestive notation.

We let $\thF \subseteq \F$ be a fixed subset of the function symbols such that
for all $(\afun :: \atype) \in \thF$: $\atype$ is a theory type.  We refer to
the elements of $\thF$ as \emph{theory symbols} (although they are also still
considered function symbols).

We also fix a set $\V$ of \emph{variables}, which are typed constants in the
same way.  $\V$ should be disjoint from $\F$, and we assume that $\V = \Vfree
\uplus \Vbound$, where both $\Vbound$ and $\Vfree$ contain infinitely many
variables of each type.
Variables will generally be referred to as $\avar,\bvar,\cvar,\Avar,\Bvar,\Cvar,
\AFvar,\BFvar,\CFvar$ or using more suggestive notation.

Finally, we fix a set $\M$ of \emph{meta-variables}, which are constants
equipped with both a type $\atype$ and an arity $k$, where $k$ is an integer
such that $0 \leq k \leq \arity(\atype)$.  Notation:
$X :: (\atype_1 \arrtype \dots \arrtype \atype_k \arrtype \btype,k) \in \M$ or
$X :: [\atype_1,\dots,\atype_k] \arrtype \btype \in \M$, for a meta-variable
with arity $k$ and type $\atype_1 \arrtype \dots \arrtype \atype_k \arrtype
\btype$ (here, $\btype$ is allowed to be an arrow type).
We require that $\Vfree = \{ (x :: \atype) \mid x :: (\atype,0) \in \M \}$; so
the non-binder variables are exactly the meta-variables with arity
$0$.  We also require that the symbols in $\F$ and $\Vbound$ are disjoint from
those in $\M$, and that there are infinitely many meta-variables of each
feasible type/arity combination.

A \emph{signature} is a tuple $\Sigma := (\Sorts,\thSorts,\F,\thF,\Vfree,
\Vbound,\M)$.

For a given signature $\Sigma = (\Sorts,\thSorts,\F,\thF,\Vfree,\Vbound,\M)$,
we let $\thVfree := \{ (\avar :: \atype) \in \Vfree \mid \atype \in \thTypes\}$,
and similar for $\thVbound$ and $\thV$.  Then, we let $\thSigma$ indicate the
signature $(\thSorts,\thSorts,\thF,\thF,\thVfree,\thVbound,
\{ \Avar :: (\atype,0) \mid (\Avar :: \atype) \in \thVfree \}$.  That is, this
signature contains only the theory sorts, theory symbols, and variables of a
theory type. Meta-variables with arity $> 0$ are \emph{not} included, even if
they have a theory type.

\subsection{In \charlie}

\begin{itemize}
\item An alphabet $\F$ is \emph{somewhat} represented by
  \texttt{charlie.trs.Alphabet}.  That is, while $\F$ can be infinite, we in
  principle assume \emph{for now} that $\F \setminus \thF$ is finite, and
  contains at most one function symbol for a given name (so for example we
  cannot have that both $(\afun :: \atype) \in \F$ and $(\afun :: \btype) \in
  \F$ if $\atype \neq \btype$).
\end{itemize}

\medskip
However, most of the sets that make up a signature are not directly represented:
\begin{itemize}
\item Every string can be a sort, and a sort is uniquely defined by the string
  representing it, so $\Sorts$ is essentially always the set of all strings.
  However, in practice, the set $\Sorts$ consists of those sorts that are
  actually \emph{used} in a generalisd TRS (see Section~\ref{sec:trs}), since
  the presence of sorts that are not actually used does not typically affect
  properties such as termination or confluence.
\item Variables and meta-variables can be renamed, and the renamings can be
  used interchangeably.  Hence, in \charlie\ these are essentially represented
  by the combination of an integer and a type.
\item If a TRS ``has theories'' (\texttt{charlie.trs.TRS::theoriesIncluded()}),
  then $\thSorts = \{\tint,\bool,\tstring\}$, otherwise $\thSorts =
  \emptyset$.
\item If a TRS ``has theories'' then $\thF$ is the infinite set consisting of:
  \begin{itemize}
  \item for all integers $i$ the symbol $i :: \tint$
  \item for all booleans $b$ the symbol $b :: \bool$ (that is, just $\strue$
    and $\sfalse$)
  \item for all string constants $s$ the symbol $s :: \tstring$
  \item the symbols $+,*,/,\% :: \tint \arrtype \tint \arrtype \tint$ and
    $- :: \tint \arrtype \tint$
  \item the symbols $\wedge,\vee :: \bool \arrtype \bool \arrtype \bool$ and
    $\neg :: \bool \arrtype \bool$
  \item the symbols $>,<,\geq,\leq,=,\neq :: \tint \arrtype \tint \arrtype
    \bool$
  \item the symbols $=,\neq :: \tstring \arrtype \tstring \arrtype \bool$
    (note that these are overloaded) \\
  \end{itemize}
  These symbols can all be created using \texttt{charlie.terms.TheoryFactory}.
  It is entirely possible (even likely) that more theory symbols will be added
  in the future.
\end{itemize}

\section{Terms}\label{sec:terms}

Terms are \emph{well-typed} expressions built over given sets of function
symbols, variables and meta-variables. The full definition is presented below.

\subsection{Term formation}\label{subsec:form}

Terms are those expressions $s$ such that $s :: \atype$ can be derived for some
$\atype \in \Types$ using the following clauses:

\begin{description}
\item[constant] if $(\afun :: \atype) \in \F$ then $\afun :: \atype$
\item[variable] if $(\avar :: \atype) \in \V$ then $\avar :: \atype$
\item[application] if $h :: \atype_1 \arrtype \dots \arrtype \atype_n \arrtype
  \btype$ with $n > 0$ and $h$ is a constant, variable, abstraction or
  meta-application, and if $s_1 :: \atype_1,\dots,s_n :: \atype_n$,
  then $h(s_1,\dots,s_n) :: \btype$
\item[tuple] if $s_1 :: \atype_1,\dots,s_n :: \atype_n$, then
  $\tuple{s_1}{s_n} :: \product{\atype_1}{\atype_n}$
\item[abstraction] if $(\avar :: \atype) \in \Vbound$ and $t :: \btype$ then
  $\abs{\avar}{t} :: \atype \arrtype \btype$
\item[meta-application] if $(\ameta :: (\atype_1 \arrtype \dots \arrtype
  \atype_k \arrtype \btype,k)) \in \M$ for some $k \geq 1$ and $t_1 :: \atype_1,
  \dots,t_k :: \atype_n$ then $\meta{\ameta}{t_1,\dots,t_k} :: \btype$
\end{description}

We let $\MTerms(\Sigma)$ denote the set of all terms built using the signature
$\F$, meta-variables $\M$ and variables $\V$.

We will identify $h() = h$.  This allows us to write any term in a form $h(s_1,
\dots,s_n)$ with $n \geq 0$, where the \emph{head} $h$ is either a constant,
variable, abstraction, tuple or meta-application.  We will often use this notation.

Moreover, for $\avar \in \Vfree$, we identify $\meta{\avar}{} = \avar$.  We will
refer to any occurrence of $\meta{\ameta}{t_1,\dots,t_k}$ with $k \geq 0$ (so
including variables in $\Vfree$) as a meta-application, and $\ameta$ is its
meta-variable.

Using this notation (so $n \geq 0, k \geq 0$), we define:
\begin{itemize}
\item A term of the form $\afun(s_1,\dots,s_n)$ is called a \emph{functional
  term} and $\afun$ is its root.
\item A term of the form $\avar(s_1,\dots,s_n)$ is called a \emph{var term}, and
  $\avar$ is its variable.
\item The \emph{variable of} an abstraction $\abs{\avar}{t}$ or a var term
  $\avar(s_1,\dots,s_n)$ is $\avar$.
\item The \emph{meta-variable of} a meta-application $\meta{\ameta}{t_1,\dots,
  t_k}$ is $\ameta$.
\item An application of the form $(\abs{\avar}{t})(s_0,\dots,s_n)$ is called a
  \emph{$\beta$-redex} and $\avar$ is its variable.
\item A term of the form $\meta{x}{t_1,\dots,t_k}(s_{k+1},\dots,s_n)$ with
  $n > k \geq 0$ is a meta-application-application, and $\avar$ is its variable.
  However, while we permit the formation of meta-application-applications to
  avoid many exceptions in for instance termination techniques, in practice we
  will typically only consider terms of this form with $k = 0$.
\end{itemize}

If $s :: \atype$ then we say that $\atype$ is the type of $s$; it is clear from
the definitions above that each term has a unique type.

Note that in the \clause{application} and \clause{meta-application} clauses, $n$
and $k$ are not required to be maximal; for example, if $\symb{greater} ::
\mathtt{int} \arrtype \mathtt{int} \arrtype \mathtt{bool}$, then each of
$\symb{greater}(),\symb{greater}(\avar)$ and $\symb{greater}(\avar,\bvar)$ are
terms (with distinct types); each having $\symb{greater}$ as its head.
Note also that a variable $\avar$ is also considered a var term, and a constant
$\afun$ is a functional term, but a plain abstraction is \emph{not} a
$\beta$-redex.

\subsection{$\alpha$-equality}
We let $=_\alpha$ be the usual $\alpha$-renaming equivalence relation as used in
the $\lambda$-calculus. This relation can be formally defined as follows:
\begin{itemize}
\item Let $\mu_0,\nu_0 : \Vbound \rightarrow \N$ be defined as follows:
  $\mu_0(\avar) = \nu_0(\avar) = 0$ for all $\avar \in \Vbound$.
\item Let $s =_\alpha t$ iff $s =_\alpha^{\mu_0,\nu_0,1} t$.
\item For $\mu,\nu : \Vbound \rightarrow \N$ and $k \in \N$, let
  $s =_\alpha^{\mu,\nu,k} t$ if and only if this can be defined by the following
  clauses:
  \begin{itemize}
  \item $\afun =_\alpha^{\mu,\nu,k} \afun$ for all $\afun \in \F$
  \item $a(s_1,\dots,s_n) =_\alpha^{\mu,\nu,k} b(t_1,\dots,t_n)$ with $n > 0$ if
    $a =_\alpha^{\mu,\nu,k} b$ and $s_i =_\alpha^{\mu,\nu,k} t_i$ for all $i \in
    \{1,\dots,n\}$;
  \item $\tuple{s_1}{s_n} =_\alpha^{\mu,\nu,k} \tuple{t_1}{t_n}$ if
    $s_i =_\alpha^{\mu,\nu,k+1} t_i$ for all $i \in \{1,\dots,k\}$.
  \item $\meta{\ameta}{s_1,\dots,s_k} =_\alpha^{\mu,\nu,k} \meta{\ameta}{t_1,
    \dots,t_k}$ if $s_i =_\alpha^{\mu,\nu,k+1} t_i$ for all $i \in \{1,\dots,
    k\}$. \\
    (Note that this includes the case where $k = 0$, so $\avar =_\alpha^{\mu,
    \nu,k} \avar$ for all $\avar \in \Vfree$.)
  \item $\avar =_\alpha^{\mu,\nu,k} \bvar$ for $\avar,\bvar \in \Vbound$ if
    either  $\avar = \bvar$ and $\mu(\avar) = \nu(\bvar) = 0$, or $\mu(\avar) =
    \mu(\bvar) > 0$;
  \item $\abs{\avar}{s} =_\alpha^{\mu,\nu,k} \abs{\bvar}{t}$ iff $s
    =_\alpha^{\mu[\avar:=k],\mu[\bvar:=k],k+1} t$; \\
    (Here, $\mu[\avar:=k]$ is the function that maps $\avar$ to $k$ and all
    other $\cvar$ to $\mu(\cvar)$; similar for $\nu[\bvar:=k]$.)
  \end{itemize}
\end{itemize}
That is, we progressively descend into the term and keep track of where
variables are bound; the structure of the two terms has to be exactly the same,
and function symbols and unbound variable should occur at the same positions in
both terms. However, when encountering a bound variable, we only require that
this variable was bound by the same $\lambda$ in both terms.  We can
straightforwardly prove that $=_\alpha$ is an equivalence relation (Corollary
\ref{corr:alphaequiv}).

\subsection{Restricted terms}\label{subsec:termsets}

The definition of terms is deliberately broad, to support a rather liberal kind
of higher-order rewriting; in some other works, what we call ``terms'' would be
referred to as \emph{metaterms}, with the word \emph{terms} referring to what we
will call ``true terms''.  We use this terminology simply because in an analysis
tool, the vast majority of reasoning happens on metaterms, so these are the
primary objects we wish to consider.

However, in practice we do often use limitations: specific kinds of terms
which are built using subsets and restrictions of the clauses in Section
\ref{subsec:form}.  We consider the most important ones:

\begin{itemize}
\item A \emph{true term} is a term without meta-applications; that is, a term
  whose type can be derived using only the clauses \clause{constant},
  \clause{variable}, \clause{application}, \clause{tuple} and
  \clause{abstraction}.

\item A term $s$ is a \emph{semi-pattern} if the arguments to a meta-application
  must all be distinct bound variables.  That is, a term whose type can be
  derived using the clauses \clause{constant}, \clause{variable},
  \clause{application}, \clause{tuple}, \clause{abstraction} and:
  \begin{description}
  \item[meta-pattern] if $(\ameta :: (\atype_1 \arrtype \dots \arrtype \atype_k
    \arrtype \btype,k)) \in \M$ for some $k > 0$ and $(\bvar_1 :: \atype_1),
    \dots,(\bvar_k :: \atype_k) \in \Vbound$ are all distinct, then
    $\meta{\ameta}{\bvar_1,\dots,\bvar_k} :: \btype$
  \end{description}
  (Note that \clause{meta-pattern} is a restriction of
  \clause{meta-application} so all semi-patterns are indeed meta-terms.  Any
  true term is necessarily a semi-pattern.)

\item A term $s$ is a \emph{pattern} if it is a semi-pattern, and moreover
  abstractions, meta-variables and non-binder variables do not occur at the head
  of an application.
  That is, a pattern is a term whose type can be derived using the clauses
  \clause{tuple}, \clause{abstraction}, \clause{meta-pattern} and:
  \begin{description}
  \item[func] if $(\afun :: \atype_1 \arrtype \dots \arrtype \atype_n
    \arrtype \btype) \in \F$ and $s_1 :: \atype_1,\dots,s_n :: \atype_n$ with
    $n \geq 0$ then $\afun(s_1,\dots,s_n) :: \btype$
  \item[bvarterm] if $(\avar :: \atype_1 \arrtype \dots \arrtype \atype_n
    \arrtype \btype) \in \Vbound$ and $s_1 :: \atype_1,\dots,s_n :: \atype_n$
    with $n \geq 0$ then $\avar(s_1,\dots,s_n) :: \btype$
  \item[freevar] if $(\avar :: \atype) \in \Vfree$ then $\avar :: \atype$
  \end{description}
  (Note that \clause{func} is a combination of \clause{constant} and
  \clause{application}; \clause{bvarterm} combines a restriction of
  \clause{variable} and \clause{application}; and \clause{freevar} is a
  restriction of \clause{variable}
  So, any expression typed using these expressions is indeed a term.)

\item Hence, a true term is a pattern if it can be typed using only
  \clause{func}, \clause{bvarterm}, \clause{freevar}, \clause{tuple} and
  \clause{abstraction}.

\item A term $s$ is \emph{applicative} if it does not use meta-applications or
  variables in $\Vbound$.  Note that this limitation excludes abstractions.
  Hence, a term is applicative if it can be typed using just the clauses
  \clause{constant}, \clause{freevar}, \clause{application} and \clause{tuple}.
  Equivalently, an applicative term can be typed using just \clause{func},
  \clause{tuple} and:
  \begin{description}
  \item[fvarterm] if $(\avar :: \atype_1 \arrtype \dots \arrtype \atype_n
    \arrtype \btype) \in \Vfree$ and $s_1 :: \atype_1,\dots,s_n :: \atype_n$
    then $\avar(s_1,\dots,s_n) :: \btype$
  \end{description}

\item Hence, an \emph{applicative pattern} can be typed using just the clauses
  \clause{func}, \clause{tuple} and \clause{freevar}.
\item A term is \emph{first-order} if it is an applicative pattern with only
  base-type subterms; that is, a term whose type can be derived using only
  \clause{tuple} and:
  \begin{description}
  \item[(fofunc)] if $(\afun :: \atype_1 \arrtype \dots \arrtype \atype_n
    \arrtype \asort) \in \F$ with $\asort \in \Sorts$ and $s_1 :: \atype_1,
    \dots,s_n :: \atype_n$ then $\afun(s_1,\dots,s_n) :: \asort$
  \item[(fovar)] if $(\avar :: \asort) \in \Vfree$ with $\asort \in \Sorts$ then
    $\avar :: \asort$.
  \end{description}

\item A \emph{theory term} is an element of $\MTerms(\thSigma)$.  Note that a
  theory is exactly a true term, whose function symbols are all from
  $\thF$ and whose variables are all from $\thV$.

\item A term is \emph{product-free} if its construction does not use product
  types.  That is, it can be typed without the clause \clause{tuple}, and if
  a variable, constant or meta-variable of a type $\atype$ is used, then its
  type does not have a product type as subtype.
\end{itemize}

We denote $\Terms(\F,\V)$ for the set of all true terms $s$, modulo $=_\alpha$.
In practice, we will reason with true terms rather than equivalence classes, but
always consider equality modulo $=_\alpha$.

The set of applicative terms is denoted $\ATerms(\F,\V)$.  Note that $=_\alpha$
is the identity on applicative terms, and that every applicative term is a true
term, so $\ATerms(\F,\V) \subseteq \Terms(\F,\V)$.

The set of first-order terms is denoted $\FOTerms(\F,\V)$.  Since every
first-order term is also an applicative pattern, $\FOTerms(\F,\V) \subseteq
\ATerms(\F,\V) \subseteq \Terms(\F,\V)$.

The set of theory terms is exactly $\Terms(\thF,\thV)$, as theory terms are
true terms by definition.

\subsection{Application}\label{subsec:application}
We have defined application as a clause, but it will sometimes be convenient to
have it as an operation.  This is defined as follows:

\begin{definition}
For any term $h(s_1,\dots,s_n) :: \atype \arrtype \btype$ (with $n \geq 0$),
and $t :: \atype$, we let $h(s_1,\dots,s_n) \cdot t$ be the term
$h(s_1,\dots,s_n,t) :: \btype$.
The application operator $\cdot$ is left-associative, so $h(s_1,\dots,s_n)
\cdot t_1 \cdots t_m$ denotes $((h(s_1,\dots,s_n) \cdot t_1) \cdot t_2) \cdots
t_m = h(s_1,\dots,s_n,t_1,\dots,t_m)$.
\end{definition}

We easily obtain the following result;

\begin{lemma}\label{lem:applicative_notation}
The set $\ATerms(\F,\V)$ is the smallest set such that:
\begin{itemize}
\item $\F \cup \Vfree \subseteq \ATerms(\F,\V)$;
\item if $s_1,\dots,s_n \in \ATerms(\F,\V)$ with $n \geq 2$ then
  $\tuple{s_1}{s_n} \in \ATerms(\F,\V)$;
\item if $s,t \in \ATerms(\F,\V)$ and $s :: \atype \arrtype \btype$ and $t ::
  \atype$ then $s \cdot t \in \ATerms(\F,\V)$.
\end{itemize}
\end{lemma}

\begin{proof}
Trivial.
\end{proof}

Lemma~\ref{lem:applicative_notation} shows that our applicative terms are the
same as applicative terms constructed in the traditional way; however, for
convenience we denote them in a functional notation.
We can similarly see easily that the set of all terms is exactly the smallest
set which includes $\F,\V$ and is closed under abstraction, meta-application,
tuple and this application operator.

Application interacts with $\alpha$-equality as you would expect: $u \cdot s_1
\cdots s_n =_\alpha v \cdot t_1 \cdots t_n$ if and only if $u =_\alpha v$ and
each $s_i =_\alpha t_i$ (Lemma \ref{lem:alphaappl}).

\subsection{Sets of (meta-)variables}
The set of \emph{free variables} of a term is inductively defined as follows:
\begin{itemize}
\item $\FV(\afun) = \emptyset$;
\item $\FV(\avar) = \{ \avar \}$;
\item $\FV(h(s_1,\dots,s_n)) = \FV(h) \cup \FV(s_1) \cup \dots \cup \FV(s_n)$ if
  $n > 0$;
\item $\FV(\tuple{s_1}{s_n}) = \FV(s_1) \cup \dots \cup \FV(s_n)$.
\item $\FV(\abs{\avar}{t}) = \FV(t) \setminus \{ \avar \}$;
\item $\FV(\meta{\Avar}{t_1,\dots,t_k}) = \FV(t_1) \cup \dots \cup \FV(t_k)$.
\end{itemize}
That is, $\FV(s)$ contains all variables in $s$ except for those bound by a
$\lambda$.
For applicative and first-order terms $s$, this is the set of \emph{all}
variables occurring in $s$.
Note that it is possible for $\FV(s)$ to contain variables in $\Vbound$.

The set of \emph{meta-variables} of a term $s$ is exactly the set containing all
the meta-variables that occur in $s$.  This is inductively defined as follows:
\begin{itemize}
\item $\FMV(\afun) = \emptyset$;
\item $\FMV(\avar) = \{ \avar \}$ if $\avar \in \Vfree$
\item $\FMV(\avar) = \emptyset$ if $\avar \in \Vbound$
\item $\FMV(h(s_1,\dots,s_n)) = \FMV(h) \cup \FMV(s_1) \cup \dots \cup
  \FMV(s_n)$ if $n > 0$;
\item $\FMV(\tuple{s_1}{s_n}) = \FMV(s_1) \cup \dots \cup \FMV(s_n)$.
\item $\FMV(\abs{\avar}{t}) = \FMV(t)$
\item $\FMV(\meta{\Avar}{t_1,\dots,t_k}) = \{ \Avar \} \cup \FMV(t_1) \cup
  \dots \cup \FMV(t_k)$.
\end{itemize}

Note that $\FV(s)$ and $\FMV(s)$ overlap on the variables in $\Vfree$ that occur
in $s$.

A term $s$ is \emph{closed} if $\FV(s) \subseteq \Vfree$.
A term $s$ is \emph{ground} if $\FV(s) = \FMV(s) = \emptyset$.

Since $\FV(s) = \FV(t)$ and $\FMV(s) = \FMV(t)$ whenever $s =_\alpha t$
(Corollary \ref{corr:alphafreevar}), $\FV$ also defines a function on
equivalence classes of terms.

\subsection{Well-formedness}

In addition, we can define the set $\BV(s)$ of \emph{bound variables} of $s$ as
the set containing all $\avar$ such that $\abs{\avar}{s'}$ occurs in $s$ for
some $s'$:

\begin{itemize}
\item $\BV(\afun) = \BV(\avar) = \emptyset$;
\item $\BV(h(s_1,\dots,s_n)) = \BV(h) \cup \BV(s_1) \cup \dots \cup \BV(s_n)$ if
  $n > 0$;
\item $\BV(\tuple{s_1}{s_n}) = \BV(\meta{\Avar}{s_1,\dots,s_n}) =
  \BV(s_1) \cup \dots \cup \BV(s_n)$.
\item $\BV(\abs{\avar}{t}) = \BV(t) \cup \{ \avar \}$;
\end{itemize}

This is \emph{not} a function on equivalence classes, since for
instance $\BV(\abs{\avar}{\avar}) = \{\avar\} \neq \{\bvar\} = \BV(\abs{\bvar}{
\bvar})$.  Instead, it can often be used to show that a definition that regards
terms rather than equivalence classes makes sense.  For example, it allows us to
define \emph{well-formedness}.

\begin{definition}\label{def:wellformed}
A term $s$ is \emph{well-formed} if $\FV(s) \cap \BV(s) = \emptyset$, and:
\begin{itemize}
\item if $s = h(s_1,\dots,s_n)$ then $h$ and all $s_i$ are well-formed
\item if $s = \tuple{s_1}{s_n}$ or $\meta{\Avar}{s_1}{s_n}$ then all $s_i$ are
  well-formed
\item if $s = \abs{\avar}{s'}$ then $\avar \notin \BV(s')$
\end{itemize}
\end{definition}

In definitions, it is often useful to assume that a given term is well-formed,
and even that certain variables are not in its bound variables.  We can safely
do so: for every finite set $X \subseteq \Vbound$ and every term $s$, there
exists a well-formed term $s'$ such that $s =_\alpha s'$ and $\BV(s') \cap
X = \emptyset$ (Lemma~\ref{lem:wellformedcounterpart}).

\subsection*{In Charlie}

\begin{itemize}
\item The class \texttt{charlie.terms.FunctionSymbol} represents function
  symbols.
\item The class \texttt{charlie.terms.Variable} represents variables
  (the function\linebreak
  \texttt{Variable::isBinderVariable()} indicates whether the
  variable is in $\Vbound$) and the class \texttt{charlie.terms.MetaVariable}
  represents meta-variables.  The class\linebreak
  \texttt{charlie.terms.Replaceable}
  is used for any of the three (this is a shared interface inherited by both
  \texttt{Variable} and \texttt{MetaVariable}).
\item The class \texttt{charlie.terms.Term} represents terms.  Note that
  function symbols and variables are also considered terms (but in general,
  meta-variables are not).
\item Function symbols, variables, meta-variables and terms can all be
  constructed using \texttt{charlie.terms.TermFactory}.  Note that, for
  flexibility with different kinds of rewriting, there are sometimes multiple
  ways to construct the same term -- for example,
  \texttt{TermFactory.createFunctionalTerm(f, lst)} builds the same term as
  \texttt{TermFactory.createApp(f, lst)}, but the former can only be used if
  \texttt{f} is a function symbol, while the latter executes the application
  constructor and can therefore be used for any head term (including
  applications).
\item The method \texttt{Term::equals(Term other)} checks $\alpha$-equality.
\item Terms can be queried whether they fall into a specific ``restricted term''
  category; for example using \texttt{Term::isTrueTerm()},
  \texttt{Term::isPattern()}, \texttt{Term::isTheoryTerm()}
  and \texttt{Term::isApplicative()}.
\item All terms are immutable, so can be copied around as needed.
\item Terms can be printed using \texttt{charlie.terms.TermPrinter} or any class
  inheriting it.
  (The in-built \texttt{toString()} is meant for debugging and unit testing, and
  should typically not be used when printing to users.)
\end{itemize}

\medskip
Some extra notes on variables and meta-variables: these are defined not by their
\emph{name}, but by their \emph{pointer}: whenever any replaceable is created,
it is automatically different from any other variable that has already been
used in the program.  Thus, to reuse a variable, simply copy the pointer.  To
print (meta-)variables, every TermPrinter works with a \emph{Renaming}: a
special mapping that assigns a name to each variable in a given set of terms.
(The names that are given to (meta-)variables during creation are used as a
default name / basis for the name by the standard term printer, but can be
entirely ignored by other implementations of TermPrinter).

The constructors in the \texttt{charlie.terms} package ensure that all terms
are well-formed: if something tries to construct a term such as $\afun(\avar,
\abs{\avar}{s})$ or $\abs{\avar}{\bfun(\abs{\avar}{\avar})}$, then the inner
variable will automatically be $\alpha$-renamed.  Please keep this in mind, as
it means that you cannot assume that the term you use is exactly the one you
created (but users never have to worry about terms being well-formed no matter
how they are constructed).

\section{Positions and subterms}

\subsection{Positions}

A \emph{position} is either:
\begin{itemize}
\item a sequence $p_1 \cdots p_n \cdot \epsilon$ of integers ($n \geq 0$), or
\item a sequence $p_1 \cdots p_n \star c$, where $n \geq 0$, $p_1,\dots,p_n,c$
  are integers and $c > 0$
\end{itemize}
The former is called a \emph{full} position, the latter a \emph{partial}
position.  If $p_i < 0$, then we typically present $p_i$ as $!q$ instead of
$-q$.  We often denote a position as a combination of head and tail; e.g.,
if $p = p_1 \cdots p_n$ then $i \cdot p$ denotes the position
$i \cdot p_1 \cdots p_n$.

Positions essentially describe the path to a specific subterm in a term.
Formally, for $s$ a term and $p$ a position, we define the \emph{subterm of $s$
at position $p$}, $s|_p$, as follows:
\begin{itemize}
\item if $p = \epsilon$ then $s|_p = s$;
\item if $p = h(s_1,\dots,s_n)$ and $p = \star i$ with $i \leq n$ then
  $s|_p = h(s_1,\dots,s_{n-i})$ \\
    (so for example $s|_{\star n} = h$ and $s|_{\star 1} =
    h(s_1,\dots,s_{n-1})$)
\item if $s = h(s_1,\dots,s_n)$ or $p = \tuple{s_1}{s_n}$ and $p = i \cdot p'$
  with $1 \leq i \leq n$, then $s|_p = s_i|_{p'}$
\item if $s = (\abs{\avar}{s})(s_1,\dots,s_n)$ with $n \geq 0$ and $p = 0 \cdot
  p'$ then $s|_p = t|_{p'}$
\item if $s = \meta{\Avar}{t_1,\dots,t_k}(s_1,\dots,s_n)$ with $n \geq 0$ and
  $p = !i$ with $i > 0$ then $s|_p = t_i|_{p'}$
\end{itemize}
For all other positions $p$, the subterm of $s$ at position $p$ is undefined.

We let $\Positions(s,\mathsf{full})$ denote the set of all full positions $p$
such that $s|_p$ is defined, and $\Positions(s,\mathsf{all})$ denote the
set of all positions $p$ (full or partial) for which $s|_p$ is defined.  Note
that both sets are finite, and that $\Positions(s,a) = \Positions(t,a)$ whenever
$s =_\alpha t$.

Hence, a subterm position $p_i = j > 0$ indicates ``descend into argument $j$
of an application, or tuple argument $j$''.  A subterm position $p_i = 0$
indicates ``descend into an abstraction (which should be at the head of the
current term)''.  A subterm position $p_i =\ !j$ indicates ``descend into
meta-argument $j$''.

If $s|_p$ has the same type as some term $u$, then $s[u]_p$ denotes $s$ with
the subterm at position $p$ replaced by $u$.  Formally, $s[u]_p$ is obtained as
follows:
\begin{itemize}
\item $s[u]_\epsilon = u$;
\item $h(s_1,\dots,s_n)[u]_{\star i} = u \cdot s_{n-i+1} \cdots s_n$;
\item $h(s_1,\dots,s_n)[u]_{i \cdot p} = h(s_1,\dots,s_{i-1},s_i[u]_p,s_{i+1},
  \dots,s_n)$;
\item $\tuple{s_1}{s_n}[u]_{i \cdot p} = \tuplelong{s_1,\dots,s_{i-1},s_i[u]_p,
  s_{i+1},\dots,s_n}$
\item $(\abs{\avar}{t})(s_1,\dots,s_n)[u]_{0 \cdot p} =
  (\abs{\avar}{t[u]_p})(s_1,\dots,s_n)$;
\item $\meta{\Avar}{t_1,\dots,t_k}(s_1,\dots,s_n)[u]_{!i \cdot p} =
  \meta{\Avar}{t_1,\dots,t_{i-1},t_i[u]_p,t_{i+1},\dots,t_k}(s_1,\dots,s_n)$.
\end{itemize}
Thus, we can find and replace the subterm at a (full or partial) given position
in $s$.

Note that $s \mapsto s|_p$ and $s \mapsto s[u]_p$ are \emph{not} operations on
equivalence classes of terms; for example, $\abs{x}{x} =_\alpha \abs{y}{y}$, but
$(\abs{x}{x})[x]_0 = \abs{x}{x} \not =_\alpha \abs{y}{x} = (\abs{y}{y})[y]_0$.
Hence, when subterms are considered this should usually be accompanied by some
result that guarantees the operation handles bound variables properly.

\emph{Remark.}
Note also that we do \emph{not} have the property that if $p$ is a position of
$s$, then $p$ is a position of $s\gamma$ for any substitution $\gamma$; for
example, $x(\afun(y))$ has a position $1 \cdot 1 \cdot \epsilon$, with
$x(\afun(y))|_{1 \cdot 1 \cdot \epsilon} = y$.  However, $x(\afun(y))[x:=
\bfun(\identifier{a})] = \bfun(\identifier{a},\afun(y))$, which does not have
this position.  If we ever need it, we could define alternative positions with
the property that if $s|_p = t$ then $(s\gamma)|_p = t\gamma$ for $s$ a proper
term.  However, we cannot have both this, and that positions correspond to the
usual definition of positions in the first-order setting.

\subsection{Subterms}

We say that \emph{$t$ is a fully applied subterm of $s$}, notation $t
\subtermeq s$, if there is a \emph{full} position $p \in \Positions(s,
\mathsf{full})$ with $t = s|_p$.  This could equivalently be formulated as
follows:

\begin{lemma}
$u \subtermeq s$ if and only if one of the following holds:
\begin{itemize}
\item $s = u$;
\item $s = h(s_1,\dots,s_n)$ and $u \subtermeq s_i$ for some $i$;
\item $s = \tuple{s_1}{s_n}$ and $u \subtermeq s_i$ for some $i$;
\item $s = (\abs{x}{t})(s_1,\dots,s_n)$ and $u \subtermeq t$;
\item $s = \meta{\Avar}{t_1,\dots,t_k}(s_1,\dots,s_n)$ and $u \subtermeq t_i$
  for some $i$.
\end{itemize}
\end{lemma}

We also observe that $\subtermeq$ is transitive:

\begin{lemma}
If $s \subtermeq t$ and $t \subtermeq q$ then $s \subtermeq q$.
\end{lemma}

This is obvious because if $t = q|_p$ and $s = t|_{p'}$ then $s = q|_{p \cdot p'}$.

It should be noted that we do \emph{not} consider, for example, $\afun(x)$ to be
a subterm of $\afun(x,y)$, since this requires a \emph{partial} position.  To be
able to refer to such subterms too, we define the following: \emph{$t$ is a
head-subterm of $s$}, notation $t \headsubtermeq s$ if $s|_p = t$ for some $p
\in \Positions(s,\mathsf{partial})$.

It should also be noted that if $s =_\alpha t$, it does not follow that $s$ and
$t$ have the same subterms: $\abs{x}{x}$ has a subterm $x$, while $\abs{y}{y}$
does not.  For applicative and first-order terms, this is not an issue.

\emph{Remark.} In contrast to most definitions of higher-order rewriting, we
consider the notion of \emph{fully applied subterm} the primary one; and if we
simply refer to ``subterm'', we usually mean this, and not head-subterms.  This
is because, using our definitions, fully applied subterms arise naturally in
recursive definitions and proofs.

Regarding different kinds of terms: the fully applied subterms and full
positions of a first-order term by these definitions are exactly the subterms
and positions as they are usually considered in first-order term rewriting;
head-subterms are generally not considered.  For applicative terms, both
subterms and head-subterms are usually referred to as just ``subterms''; we
distinguish them here because doing so is practical for analysis.

\subsection*{In Charlie.}

\begin{itemize}
\item The class \texttt{charlie.terms.position.Position} represents positions
  (both full and partial).
\item There is no factory for positions; instead, if you have a need for one,
  you can either read it from string using \texttt{Position::parse(String txt)}
  or create one of:
  \begin{itemize}
  \item \texttt{charlie.terms.position.ArgumentPos}(i,p) for $i \cdot p$
  \item \texttt{charlie.terms.position.LambdaPos}(i,p) for $0 \cdot p$
  \item \texttt{charlie.terms.position.MetaPos}(i,p) for $!i \cdot p$
  \item \texttt{charlie.terms.position.FinalPos}(0) for $\epsilon$, and
  \item \texttt{charlie.terms.position.FinalPos}(k) for $\star k$.
  \end{itemize}
\item To obtain $\Positions(s,\mathsf{full})$, use
  \texttt{$s$.queryPositions(false)}. \\
  To obtain $\Positions(s,\mathsf{partial})$, use
  \texttt{$s$.queryPositions(true)}.
\item Alternatively, for a term $s$ the function
  \texttt{$s$.querySubterms()} yields the list of all pairs $(s|_p,p)$ for
  $p \in \Positions(s,\mathsf{full})$.  Use \texttt{Term::visitSubterms} to
  execute a function for all pairs $(s|_p,p)$ of a fully applied subterm and a
  full position.
\item To obtain $s|_p$, use \texttt{$s$.querySubterm($p$)}.
\item To obtain $s[u]_p$ use \texttt{$s$.replaceSubterm($p$, $u$)}.
\end{itemize}

\section{Substitution}

A \emph{substitution} is a partial function $\gamma$ that maps:
\begin{itemize}
\item \emph{variables} $\avar :: \atype$ to terms of type $\atype$
\item \emph{meta-variables} $\Avar :: (\atype,k)$ to terms $\abs{\bvar_1 \dots
  \bvar_k}{t}$ of type $\atype$
\end{itemize}
The \emph{domain} $\domain(\gamma)$ of a substitution $\gamma$ is the set of
variables and meta-variables for which $\gamma$ is defined; note that (in
contrast to some of the literature) this includes those $\avar$ with
$\gamma(\avar) = \avar$.
We denote $[x_1:=s_1,\dots,x_n:=s_n]$ for the substitution $\gamma$ with
domain $\{x_1,\dots,x_n\}$ that maps each $x_i$ to $s_i$; finite substitutions
can always be denoted in such a form.
%For variables $\avar$ not in the domain of $\gamma$, we will slightly abuse
%notation and denote $\gamma(\avar) = \avar$; for meta-variables $\Cvar ::
%(\atype,k)$ not in the domain of $\gamma$ we denote $\gamma(\Cvar) =
%\abs{\avar_1 \dots \avar_k}{\meta{\Cvar}{\avar_1,\dots,\avar_k}}$.
Applying a substitution $\gamma$ to a term $s$, notation $s\gamma$, yields a
new term of the same type, by the following clauses:

\begin{itemize}
\item $\afun\gamma = \afun$;
\item $\avar\gamma = \gamma(\avar)$ if $\avar \in \domain(\gamma)$;
\item $\avar\gamma = \avar$ if $\avar \notin \domain(\gamma)$;
\item $h(s_1,\dots,s_n)\gamma = (h\gamma) \cdot (s_1\gamma) \cdots (s_n\gamma)$
  if $n > 0$;
\item $\tuple{s_1}{s_n}\gamma = \tuple{s_1\gamma}{s_n\gamma}$;
\item $(\abs{\avar}{t})\gamma = \abs{\cvar}{(t ([\avar:=\cvar] \cup [\bvar:=
  \gamma(\bvar) \mid \bvar \in \domain(\gamma) \setminus \{\avar\}]))}$ \\
  for $\cvar$ a \emph{fresh}** variable in $\Vbound$ with the same type as
  $\avar$;
\item $\meta{\Avar}{s_1,\dots,s_k}\gamma = \meta{\Avar}{s_1\gamma,\dots,s_k
  \gamma}$ if $k > 0$ and $\Avar \notin \domain(\gamma)$;
\item $\meta{\Avar}{s_1,\dots,s_k}\gamma = t[\bvar_1:=s_1\gamma,\dots,\bvar_k:=
  s_k\gamma]$ if $k > 0$ and $\Avar \in \domain(\gamma)$ and $\Avar =
  \abs{\bvar_1 \dots \bvar_k}{t}$.
  (Here, if some $\bvar_i = \bvar_j$ for $i < j$, the substitution $[\bvar_1:
  =u_1,\dots,\bvar_n:=u_n]$ maps $\bvar_i$ to $u_j$.)
\end{itemize}
** A \emph{fresh} variable $\cvar$ is one that does not occur in
$\FV(\bvar\gamma)$ for any $\bvar \in \FV(s)$, nor in
$\FV(\gamma(\Avar))$ for any $\Avar \in \FMV(s) \cap \domain(\gamma)$.

Due to the case for meta-application, it is not immediately obvious that these
definitions are well-founded: it is not the case that each step is defined in
terms of an obviously smaller substitution.  However, we can see this in two
steps: substitutions are well-defined when $\domain(\gamma) \subseteq \Vbound$
(since then the meta-application case does not occur); and we can use this as a
prerequisite to see that all substitutions are well-defined (Lemma
\ref{lem:substdefined}).

More critically, these definitions technically do not define functions on terms:
the substitution of an abstraction may lead to any fresh variable being chosen.
Hence, we should perhaps think of these notions as defining \emph{relations}
between terms.  However, they do define a function on \emph{equivalence classes}
(by Corollary \ref{cor:substitutionalpha}):
\begin{itemize}
\item if $s_1 =_\alpha s_2$ and $s_1\gamma = t_1$ and $s_2\gamma' = t_2$ and
  $\domain(\gamma) = \domain(\gamma')$ and
  $\gamma(x) =_\alpha \gamma'(x)$ for all $x \in (\FV(s_1) \cup \FMV(s_1)) \cap
  \domain(\gamma)$, then $t_1 =_\alpha t_2$;
\item if $s_1 =_\alpha s_2$ and $s_1\gamma = t_1$ and $s_2\gamma = t_2$ then
  $t_1 =_\alpha t_2$ \\
  (this is a special case of the previous item, but it is highlighted since it
  shows that substitution by a specific $\gamma$ defines a function);
\end{itemize}
Hence, the difference is not significant, and we can safely think of
substitution as defining a function.

For two substitutions $\gamma$ and $\delta$, we let $\gamma\delta$ denote the
substitution $[\avar := \gamma(\avar)\delta \mid \avar \in \domain(\gamma)] \cup
[\avar := \delta(\avar) \mid \avar \in \domain(\delta) \setminus
\domain(\gamma)]$.
We can prove (Lemma \ref{lem:combinesubst}) that $s(\gamma\delta)$ is exactly
$(s\gamma)\delta$.

\subsection*{In Charlie}

\begin{itemize}
\item Substitutions are represented by \texttt{charlie.terms.Substitution}.
  Note that in principle, substitutions are \emph{mutable} objects, since they
  can be extended or have mappings removed.
\item Note that the domain of a substitution is a set of \emph{replaceables}
  (which can be variables or meta-variables).
\item In line with the common convention to denote $\gamma(\avar) = \avar$ for
  variables $\avar \notin \domain(\gamma)$, the function
  \texttt{Substitution::getReplaceablement(Variable x)} always returns a term
  (but \texttt{Substitution::get(Replaceable x)} does not, since there is no
  default mapping for a meta-variable of arity $> 1$).
\end{itemize}

\section{Models}\label{sec:models}

For every sort $\asort$ in $\thSorts$, we assume given a non-empty set
$\I_\asort$; for example $\I_{\tint} = \mathbb{Z}$.  We use this to generate an
associated (non-empty) set for \emph{all} theory types:
\begin{itemize}
\item $\I_{\atype \arrtype \btype}$ is the set of all functions from
  $\I_\atype$ to $\I_\btype$
\item $\I_{\product{\atype_1}{\atype_n}} = \I_{\atype_1} \times \dots \times
  \I_{\atype_n}$
\end{itemize}
Then, for every function symbol $(\afun :: \atype) \in \thF$, we assume given
an element $\J_\afun \in \I_\atype$.  For example, $\J_+$ might be the
commonly used addition operator on integers.

For a sort $\asort \in \thSorts$, let $\Val_\asort = \{ (\afun :: \atype) \in
\thF \mid \atype = \asort \}$.
We let $\Val := \bigcup_{\asort \in \thSorts} \Val_\asort$, and call its
elements \emph{values}.
The remaining symbols in $\thF \setminus \Val$ are called \emph{calculation
symbols}.

The pair of functions $(\I,\J)$ is a \emph{model} for $\Sigma$ if the following
conditions are satisfied:
\begin{itemize}
\item For every $\asort \in \thSorts$, $\J$ defines a bijection between
  $\Val_\asort$ and $\I_\asort$.
\item If $\thSorts \neq \emptyset$, then there is a sort $\bool \in \thSorts$
  such that $\I_\bool = \{\top,\bot\}$, and there exist exist symbols
  $\wedge :: \bool \arrtype \bool \arrtype \bool,\vee :: \bool \arrtype \bool
  \arrtype \bool,\neg :: \bool \arrtype \bool \in \thF$ such that
  $\J_\wedge =$ ``boolean conjunction'', $\J_\vee =$ ``boolean disjunction'' and
  $\J_\neg =$ ``boolean negation''.
  Moreover, for all $\asort \in \thSorts$ there must be some symbol $=_\asort
  :: \asort \arrtype \asort \arrtype \bool \in \thF$ such that
  $\J_{=_\asort}$ = ``equality on $\I_\asort$''.
\end{itemize}

Although the definition of a model leaves the name of the Boolean sort and the
standard boolean values and operators open, we will refer to the sort as
$\bool$, the values as $\strue$ and $\sfalse$, and the operators as $\wedge$,
$\vee$ and $\neg$ respectively.  We will also refer to equality function
symbols as either $=_\asort$, or just $=$, or $\leftrightarrow$ in the case of
$=_\bool$.

We can extend the interpretation function $\J$ from theory symbols to all ground
theory terms.  To this end, we define $\interpret{s}_\chi$ for $s \in
\Terms(\thFext,\Vbound)$ and $\chi$ a partial function whose domain includes
at least $\FV(s)$, and which maps variables $x :: \atype$ to elements of
$\I_\atype$, as follows:
\begin{itemize}
\item $\interpret{\afun}_\chi = \J_\afun$
\item $\interpret{\avar}_\chi = \chi(\avar)$
\item $\interpret{h(s_1,\dots,s_n)}_\chi =
  \interpret{h}_\chi(\interpret{s_1}_\chi,\dots,\interpret{s_n}_\chi)$
  \\ (so we apply the function $\interpret{h}_\chi$)
\item $\interpret{\tuple{s_1}{s_n}}_\chi =
  (\ \interpret{s_1}_\chi,\ \dots,\ \interpret{s_n}_\chi\ )$
\item $\interpret{\abs{\avar}{s}}_\chi =
  a \mapsto \interpret{s}_{\chi[\avar:=a]}$
  \\ (so we construct a function; if $\avar :: \atype$ then $a$ should be
  in $\I_\atype$)
\end{itemize}
This is well-defined: if $s :: \atype$ then $\interpret{s}_\chi \in \I_\atype$,
and if $s =_\alpha t$ then $\interpret{s}_\chi = \interpret{t}_\chi$.
We can also see that $\interpret{(\abs{\avar}{s})(t)}_\chi =
\interpret{s}_{\chi[\avar:=\interpret{t}_\chi]}$.

For ground terms $s$ we let $\interpret{s}$ denote $\interpret{s}_{[]}$.

A \emph{constraint} is a theory term of type $\bool$.  We say that a constraint
$s$ is \emph{valid} if for all functions $\chi$ from variables $(\avar ::
\atype) \in \FV(s)$ to $\I_\atype$ we have: $\interpret{s}_\chi = \top$.
It is \emph{satisfiable} if there is a function $\chi$ such that
$\interpret{s}_\chi = \top$.

\subsection*{In \charlie}

\charlie\ does not actively represent models, but rather, admits only theories
for which the model is known: integers, booleans and (to a very limited extent)
strings.  Essentially, this knowledge of the underlying theory is exploited in
the SMT and SOLVESMT modules.  If support for further theories (or even custom
theories) is added in the future, the main place to do this is in these two
modules.

As noted before, a TRS (see Section~\ref{sec:trs}) either ``has theories''
(given by the method \texttt{charlie.trs.TRS::theoriesIncluded()}), which
means that $\thSorts = \{\tint,\bool,\tstring\}$, or it does not, in which case
$\thSorts = \emptyset$.  This is defined when the TRS is created.

\section{Rules and reduction}

\subsection{Unconstrained rules}

An \emph{unconstrained rule} is a pair of expressions $\ell \arrz r$ such that:
\begin{itemize}
\item $\ell$ and $r$ are closed terms of the same type
%\item $\ell$ is not a meta-variable application $\meta{\Avar}{\ell_1,\dots,
%  \ell_k}$ with $k \geq 0$ (so also not a variable)
\item there is no substitution $\gamma$ such that $\ell\gamma$ is a theory term
%\item $\FMV(r) \setminus \FMV(\ell) = \emptyset$
\end{itemize}

These requirements are deliberately minimalistic: unlike many other sources, we
do \emph{not} require that the left-hand side is not a variable, or that $\FV(r)
\subseteq \FV(\ell)$.  This is because such rules might arise due to TRS
transformations.  While we will usually assume that $\ell$ is not a
meta-variable application $\meta{\Avar}{\ell_1,\dots,\ell_k}$ with $k \geq 0$
(so also not a variable), and that $\FMV(r) \setminus \FMV(\ell) = \emptyset$,
we might not need both properties for all techniques -- and hence can be more
permissive in specific techniques if desired.

The requirement that rules are type-preserving is standard in any form of
rewriting with types.  The requirement that rules are closed merely states that
$\FV(\ell) \cup \FV(r) \subseteq \Vfree$; this is not a real restriction, but it
ensures that matching is just on meta-variables, and thus makes it easier to
reason about rules, reduction and subterms.

%Next, we require that no fresh meta-variables are introduced in the right-hand
%side.  This corresponds to the usual requirement in rewriting that no fresh
%variables are introduced in the right-hand side (and implies it, since
%$\Vfree \subseteq \M$, but also extends it to meta-variables of higher arity).
%
%The last requirement corresponds to the usual requirement that variables cannot
%be the left-hand side of a rule, as this would allow any term of that type to be
%reduced.  We extend this here to meta-variable applications, which would have
%the same effect.
%Note that (unlike many sources) we do \emph{not} require that $\ell$ has a shape
%$\afun(\ell_1,\dots,\ell_k)$ with $\afun \in \F$, or that $\ell$ is a pattern.
%While this is typically true for realistic systems, exceptions are possible
%(for example, the regularly used $\eta$ rule $\abs{\avar}{\AFvar(\avar)} \arrz
%\AFvar$), so a priori we do not require it.  However, analysis techniques will
%often be limited to either disallow such rules, or allow it only for a few
%special cases (such as the $\eta$ rule).

As for the second requirement: note that if $\thSorts = \emptyset$ then there
are no theory terms, so if we are reasoning in a system without theories, the
last rule does not apply. (And in systems with $\thSorts \neq \emptyset$, we
would typically use \emph{constrained rules} instead).
This rule is given in a semantic way (quantifying over all possible
substitutions), but if $\ell$ is a \emph{semi-pattern} this restriction
coincides with $\ell$ being a theory term.  If $\ell$ is not a semi-pattern it
is a bit more complicated, because for instance if $\forall :: (\tint \arrtype
\bool) \arrtype \bool \in \thF$ and $\bfun :: \tint \arrtype \bool \in \F
\setminus \thF$, then $\forall(\abs{\avar}{\meta{\AFvar}{\bfun(\avar)}})$ has a
non-theory subterm $\bfun(\avar)$, but could still be instantiated to a theory
term by choosing, e.g., $\gamma(\AFvar) = \abs{\bvar}{\strue}$.

\myparagraph{Reduction}
For terms $s,t$, position $p \in \Positions(s,\mathsf{all})$ and unconstrained
rule $\rho = \ell \arrz r$, we say that \emph{$s$ reduces to $t$ by rule $\rho$
at position $p$} if there exists a substitution $\gamma$ such that $s|_p =
\ell\gamma$ and $t = s[r\gamma]_p$.

Note that this explicitly includes applications of rules at the head of a
subterm.

\subsection{Constrained rules}

We say that a theory type $\atype$ \emph{is represented} in $\thF$ if,
\begin{itemize}
\item $\atype$ is a product type $\tuple{\atype_1}{\atype_n}$ and each
  $\atype_i$ is represented, or
\item $\atype$ is not a product type and there is a set $\Reps{\atype} \subseteq
  \thF$ such that $\J$ gives a one-to-one mapping from $\Reps{\atype}$ to
  $\I_\atype$.
\end{itemize}
For product types $\atype = \tuple{\atype_1}{\atype_n}$, we let $\Reps{\atype}$
denote the set $\{ \tuple{v_1}{v_n} \mid v_i \in \Reps{\atype_i} \}$.
Inductively, $\Reps{\atype}$ is thus defined for all represented types $\atype$.
If $\atype$ is represented in $\thF$, and $a \in \I_\atype$, we say that
$\avalue :: \atype$ is the representative of $a$ if $\avalue$ is the unique term
in $\Reps{\atype}$ such that $\interpret{\avalue} = a$.

Note that all theory sorts are represented (by the values of this sort), as are
tuples built from only theory sorts.  In tpyical applications arrow types are
not, but there is nothing stopping us from including a set of representatives
for a given arrow type into $\thF$.

Now, given that $\thSorts \neq \emptyset$,
a \emph{constrained rule} is a triple of expressions $\ell \arrz r \mid
\varphi$, such that:
\begin{itemize}
\item $\ell$ and $r$ are closed terms of the same type
%\item $\ell$ is not a meta-variable application $\meta{\Avar}{\ell_1,\dots,
%  \ell_k}$ with $k \geq 0$ (so also not a variable)
\item there is no substitution $\gamma$ such that $\ell\gamma$ is a theory term
%\item $\FMV(r) \setminus \FMV(\ell) \subseteq \FV(\varphi)$
\item $\varphi$ is a closed constraint
\item for any $(\avar :: \atype) \in \FV(\varphi)$:
  if $\avar \in \FV(\ell) \cup \FV(r)$ then $\atype$ is represented in
  $\thF$
\end{itemize}

The first two requirements are the same as for unconstrained rules.
%The fourth differs in that fresh variables are allowed in the right-hand side of a
%rule provided they occur in the constraint.  Such a fresh variable could be
%obtained through a calculation in the constraint, or it could serve to model
%user input or non-determinism.
%
The other two requirements are new to constrained rewriting.  The main one is
the addition of a constraint $\varphi$: this constraint imposes limitations on
the substitutions to reduce using this rule.  For example (as we will see
below), to evaluate a rule with constraint $\avar \geq 0$, the variable
$\avar$ should be instantiated to a value $\avalue$.

The last requirement states that variables that occur free both in the
constraint and in the body (left- or right-hand side) of a rule, must have a
type that is represented in $\thF$.  That is, we think of the constraint as a
limitation in the theory world: it reasons about specific elements in a
mathematical set.  Validity or satisfiability of a constraint does \emph{not}
depend on which symbols exist on a term level: a constraint $F(12,3) =_\tint
36$ is by definition satisfiable even if $\thF$ does not contain symbols like
$*$ or $+$.  Yet, the body of the rule reasons about the term level: variables
in the left- or right-hand side must be instantiated by terms.  Hence, we
require that if a variable occurs in both constraint and body of the rule,
each element in the mathematical set must have a representative at the term
level.
In practice, we will typically limit interest to variables with type order $0$,
which guarantees representation through values (or tuples of values).

=====================

We write $\LVar{\ell \arrz r \mid \varphi} = \FV(\varphi)$.  These are the
variables that should be thought of as ``something in the theory''.
We let $\TLVar{\ell \arrz r \mid \varphi} = \FV(\varphi) \cap (\FV(\ell) \cup
\FV(r))$.  These are the variables that play a role both at the term level and
the theory level.

\myparagraph{Reduction}
For terms $s,t$, position $p \in \Positions(s,\mathsf{all})$ and rule $\rho =
\ell \arrz r \mid \varphi$, we say that \emph{$s$ reduces to $t$ by rule $\rho$
at position $p$} if there exists a substitution $\gamma$ such that
\begin{itemize}
\item $s|_p = \ell\gamma$ and $t = s[r\gamma]_p$
\item for all $(\avar :: \atype) \in \TLVar{\rho}$:
  $\gamma(\avar) \in \Reps{\atype}$
\item $\varphi\gamma$ is satisfiable
\end{itemize}

%For convenience of reasoning, let us extend the function $\Reps{}$: if $\atype$
%is \emph{not} represented in $\thF$, then we let $\Reps{\atype}$ be a set of
%fresh function symbols with the same cardinality as $\I_\atype$, and we extend
%$\J$ to define a one-to-one mapping between $\Reps{\atype}$ and $\I_\atype$.
%Then we can also use the interpretation function $\interpret{\cdot}$ on terms
%over $\thF \cup \bigcup_{\atype \in \thTypes} \Reps{\atype}$, and rephrase
%reduction at position $p$ as follows: there exists a substitution $\gamma$
%on domain $\FMV(\ell) \cup \LVar(\ell \arrz r \mid \varphi)$ such that:
In the very common scenario where all types of variables in $\varphi$ are
represented, we can alternatively reformulate reduction at position $p$ as the
existence of a substitution $\gamma$ with:
\begin{itemize}
\item $s|_p = \ell\gamma$ and $t = s[r\gamma]_p$
\item for all $(\avar :: \atype) \in \LVar{\rho}$:
  $\gamma(\avar) \in \Reps{\atype}$
\item $\interpret{\varphi\gamma} = \top$
\end{itemize}

For $\rho = \ell \arrz r \mid \varphi$, let $\Rules_\rho$ be the set of
unconstrained rules $\ell\gamma \arrz r\gamma$ where $\gamma$ is a
substitution on domain $\TLVar{\rho}$, mapping each $\avar :: \atype$ in its
domain to an element of $\Reps{\avar}$, such that $\varphi\gamma$ is
satisfiable.
Then for terms $s,t$ we have that $s$ reduces to $t$ by rule $\rho$ at position
$p$ if and only if there is some $\rho' \in \Rules_\rho$ such that $s$ reduces
to $t$ by rule $\rho'$.  That is, constrained rules can be seen as a rule
scheme, generating a possibly infinite set of unconstrained rules.  This
property allows us to extend results from unconstrained rules to constrained
rules without having to redo the complete proofs.

\subsection{Theory rules}

Our final group of rules are \emph{theory rules}.  These are triples $\ell
\arrz r \mid \varphi$ where
\begin{itemize}
\item $\ell$ and $r$ are closed \emph{theory terms} of the same sort
\item $\ell$ has a form $\afun(\ell_1,\dots,\ell_m)$ with $m > 0$
\item the constraint $\neg \varphi \vee \ell =_\asort r$ is valid, where
  $\asort$ is the type of $\ell$
\item $\FV(r) \setminus \FV(\ell) \subseteq \FV(\varphi)$
\item for any $(\avar :: \atype) \in \FV(\varphi)$:
  if $\avar \in \FV(\ell) \cup \FV(r)$ then $\atype$ is represented in
  $\thF$
\end{itemize}

Theory rules offer a (limited) way to rewrite theory terms, which otherwise
cannot be reduced (since constrained or unconstrained rules have a left-hand
side that cannot be instantiated to a theory term).  These rules can only
reduce base-type terms, cannot reduce values, and reducing a ground theory
term with a theory rule does not change the interpretation of the term.
This last point is essential to be able to reason about theories at all.

The purpose of theory rules is to allow some evaluation of the theory within the
term level, while preserving the theoretical properties.  For example, they
allow us to reduce $1+2$ to $3$, or $\forall(F,3,9)$ to $F(3) \wedge \forall(F,
4,9)$.  They are quite restrictive, because there is no clear use case to for
instance allow meta-variables with higher arity in theory rules -- while it
\emph{would} further complicate analysis due to mixing of the syntactical and
semantical level.

A particularly important group of theory rules are \emph{calculation rules}:
theory rules of the form
  $\afun(\avar_1,\dots,\avar_k) \arrz \bvar \mid \bvar = \afun(\avar_1,\dots,
  \avar_k)$ where $\afun :: \atype_1 \arrtype \dots \arrtype \atype_k \arrtype
  \asort \in \thF$ with $k > 0$.
For a given signature $\Sigma$, we let $\Rulescalc^\Sigma$ be the set of all
calculation rules that can be formed for this signature.

\myparagraph{Reduction}
The reduction relation for theory rules is the same as for constrained rules:
for terms $s,t$, position $p \in \Positions(s,\mathsf{all})$ and rule $\rho =
\ell \arrz r \mid \varphi$, we say that \emph{$s$ reduces to $t$ by rule $\rho$
at position $p$} if there exists a substitution $\gamma$ such that
\begin{itemize}
\item $s|_p = \ell\gamma$ and $t = s[r\gamma]_p$
\item for all $(\avar :: \atype) \in \TLVar{\rho}$:
  $\gamma(\avar) \in \Reps{\atype}$
\item $\varphi\gamma$ is satisfiable
\end{itemize}

\subsection{Sets of rules}

We typically consider sets of rules, which contain constrained rules,
unconstrained rules and theory rules.

For $\Rules$ a (possibly infinite) set of rules, we say that \emph{$s$ reduces
to $t$ by $\Rules$}, denoted $s \arr{\Rules} t$, if there
exist a position $p \in \Positions(s,\mathsf{partial})$ and rule $\rho \in
\Rules$ such that $s$ reduces to $t$ by rule $\rho$ at position $p$.

We can see that $\arr{\Rules}$ really does define a reduction on the set of terms:

\begin{lemma}
If $s =_\alpha s'$ and $s \arr{\Rules} t$ then exists $t'$ with $t =_\alpha t'$
such that $s' \arr{\Rules} t'$.
\end{lemma}

\myparagraph{Notation} If $\varphi = \strue$, and $\FV(r) \subseteq \FV(\ell)$,
then we denote the constrained rule or theory rule $\ell \arrz r \mid \varphi$
as just $\ell \arrz r$, and consider it as an unconstrained rule.
There is no risk of confusion because the reduction relation for the constrained
and the unconstrained rule are exactly the same in this case.

We will often refer to rules as $\ell \arrz r \mid \varphi$ in general.  This
also includes unconstrained rules: in this case  we let $\varphi = \strue$
(even if $\thSorts = \emptyset$ and therefore $\strue$ is not a term).

\myparagraph{Kinds of rules}

A rule $\ell \arrz r \mid \varphi$ is:
\begin{itemize}
\item a \emph{pattern rule} if $\ell$ is a pattern;
\item a \emph{semi-pattern} rule if $\ell$ is a semi-pattern;
\item \emph{first-order} if both $\ell$ and $r$ are first-order;
\item \emph{applicative} if both $\ell$ and $r$ are applicative;
\item \emph{left-linear} if $\ell$ is linear: that is, for every $\Avar \in
  \FMV(\ell)$ there is at most one position $p$ such that $\ell|_p$ has a form
  $\meta{\Avar}{\ell_1,\dots,\ell_k}$;
\item \emph{meta-free} if $\FMV(\ell) = \FV(s)$.
\item \emph{unconstrained} if $\varphi = \strue$, $\ell$ is not a theory term
  and $\FMV(r) \subseteq \FMV(\ell)$
\item a \emph{theory rule} if $\ell$ is a theory term
\item a \emph{calculation rule} if it has the form
  $\afun(\avar_1,\dots,\avar_k) \arrz \bvar \mid \bvar = \afun(\avar_1,\dots,
  \avar_k)$ where $\afun :: \atype_1 \arrtype \dots \arrtype \atype_k \arrtype
  \asort \in \thF$ with $k > 0$
\end{itemize}
If $\ell$ has a form $\afun(\ell_1,\dots,\ell_k)$ then we say that $\afun$ is
\emph{the root} of the rule $\ell \arrz r$.  (However, it is in principle not
mandatory for the left-hand side to have such a shape.)

\subsection*{In \charlie}

\begin{itemize}
\item Both constrained, unconstrained and theory rules are represented by
  \texttt{charlie.trs.Rule}.
\item Rules can be created using \texttt{charlie.trs.TrsFactory}.
\item \emph{For now}, \charlie\ does not allow the explicit creation of theory
  rules.  Rather, if theories are included, then all the corresponding
  \emph{calculation rules} are included, as a single rule scheme
  ``Calc''.  These are first-order rules, since our theories do not yet admit
  higher-order calculation symbols.
\item \emph{For now}, \charlie does not admit higher-order variables or tuple
  variables in constraints, because this is not yet supported by the SMT
  modules.  This is very likely to change in the (near) future.
\end{itemize}

\section{Generalised term rewriting systems}\label{sec:trs}

\begin{definition}
A \emph{generalised term rewriting system (TRS)} is tuple $(\Sigma,\MM,\Rules,
\termsset)$ of a signature $\Sigma = (\Sorts,\thSorts,\F,\thF,\Vbound,\Vfree,
\M)$, a model $\MM$ for that signature, a set of (constrained or unconstrained)
rules and a set $\termsset \subseteq \Terms(\F,\V)$ of true terms over $\F$
such that $\termsset$ is closed under $\arr{\Rules}$.
This generates the abstract rewriting system $(\termsset,\arr{\Rules})$.
\end{definition}

The use of a subset $\termsset \subseteq \Terms(\F,\V)$ allows us to for
instance consider first-order (many-sorted) TRSs (where $\termsset =
\FOTerms(\F,\Vfree)$ and all rules are first-order), applicative TRSs (where
$\termsset = \ATerms(\F,\Vfree)$ and all rules are applicative), or TRSs where
tuples and product types are not allowed in term formation.

While it is perfectly allowed for a generalised TRS to have infinitely many
rules, in practice this can be hard to work with (and particularly to automate).
Hence, we often use \emph{rule schemes}, which are ways to represent an infinite
number of rules.  Some examples:
\begin{itemize}
\item Beta: for all $\atype,\btype \in \Types$,
  a rule $(\abs{\avar}{\meta{\Bvar}{\avar}})(\Cvar) \arrz \meta{\Bvar}{\Cvar}$
  with $\Cvar :: \atype$ and $\Bvar :: [\atype] \arrtype \btype$
\item Eta: for all $\atype,\btype \in \Types$,
  a rule $\abs{\avar}{\Bvar(\avar)} \arrz \Bvar$
  with $\Bvar :: [] \arrtype \atype \arrtype \btype$
\item Calc: for all calculation symbols $(\afun :: \asort_1 \arrtype \dots
  \arrtype \asort_k \arrtype \bsort) \in  \thF$ with $\asort_1,\dots,\asort_k,
  \bsort \in \thSorts$, a rule $\afun(\avar_1,\dots,\avar_k) \arrz \bvar \mid
  \bvar = \afun(\avar_1,\dots,\avar_k)$
%\item Project: for all types $\atype_1,\dots,\atype_n$, all $i \in \{1,\dots,
%  n\}$, a rule $\pi_i^{\vec{\atype}}(\tuple{\avar_1}{\avar_n}) \arrz \avar_i$,
%  where $\pi_i^{\vec{\atype}} :: \tuple{\atype_1}{\atype_n} \arrtype \atype_i$
%  is then also included in $\F$
\end{itemize}

\subsection{Examples of TRSs}

We particularly consider the following kinds of TRSs:

\myparagraph{MSTRS}
A \emph{many-sorted term rewriting system} is a TRS with:
\begin{itemize}
\item $\thSorts = \emptyset$;
\item $\termsset = \FOTerms(\F,\Vfree)$;
\item for all $(\afun : \atype) \in \F$: $\order(\atype) \leq 1$;
\item the left- and right-hand side of each rule is a first-order term
\item product types are excluded; that is:
  \begin{itemize}
  \item product types do not occur even as a subtype of the type of any
    element of $\F$
  \item terms both in $\termsset$ and in left- an right-hand sides of rules must
    be product-free
  \end{itemize}
\end{itemize}

An \emph{unsorted first-order term rewriting system} is a many-sorted term
rewriting system with $\Sorts = \{ \unitsort \}$.  Note that in an MSTRS,
necessarily rules have a form $\afun(\ell_1,\dots,\ell_k) \arrz r$, since
other shapes are excluded.

In some cases, we may also consider MSTRSs where product types are included.
This can be seen as a variant of MSTRSs, or could be encoded into an MSTRS, by
viewing each product type $\tuple{\asort_1}{\asort_n}$ as a separate sort, and
introducing tuple symbols $\symb{tuple}_{\vec{\asort}} :: \asort_1 \arrtype
\dots \arrtype \asort_n \arrtype \tuple{\asort_1}{\asort_n}$ for all sequences
$\asort_1,\dots,\asort_n$ with $n \geq 2$.

\myparagraph{LCTRS}
A \emph{logically constrained term rewriting system} is a TRS with:
\begin{itemize}
\item $\thSorts \neq \emptyset$;
\item $\termsset = \FOTerms(\F,\Vfree)$;
\item for all $(\afun : \atype) \in \F$: $\order(\atype) \leq 1$;
\item the left- and right-hand side of each rule is a first-order term
\item product types are excluded
\item the theory rules in $\Rules$ are exactly the calculation rules of the
  signature: \\
  $\{ \rho \in \Rules \mid \rho$ is a theory rule $\} = \Rulescalc^\Sigma$
\end{itemize}

\myparagraph{STRS}
A \emph{simply-typed rewriting system} is a TRS with:
\begin{itemize}
\item $\thSorts = \emptyset$;
\item $\termsset = \ATerms(\F,\Vfree)$
\item the left- and right-hand side of each rule is an applicative term
\end{itemize}

An STRS may also be limited to allow only \emph{pattern rules} (that is, the
left-hand side of each rule is a pattenr), or to exclude product types (as
above).

\myparagraph{LCSTRS}
A \emph{logically constrained simply-typed rewriting system} is a TRS with:
\begin{itemize}
\item $\thSorts \neq \emptyset$;
\item $\termsset = \ATerms(\F,\Vfree)$
\item the left- and right-hand side of each rule is an applicative term
\item $\order(\atype) \leq 1$ for all $(\afun :: \atype) \in \thF$
\item the constraint of each rule is a first-order term
\item the theory rules in $\Rules$ are exactly the calculation rules of the
  signature
\end{itemize}

Similarly to STRSs, an LCSTRS may also be limited to allow only pattern rules
or to exclude product types.

\myparagraph{CFS}
A \emph{curried functional system} is a TRS with
\begin{itemize}
\item $\thSorts = \emptyset$
\item $\termsset = \Terms(\F,\V)$
\item the left- and right-hand sides of rules are true terms
\end{itemize}

A CFS may also be limited to allow only pattern rules, or to exclude product
types.

\myparagraph{AMS}
An \emph{applicative meta-variable system} is a TRS with
\begin{itemize}
\item $\thSorts = \emptyset$
\item $\termsset = \Terms(\F,\V)$
\item the left- and right-hand sies of rules are semi-patterns
\item product types are excluded
\end{itemize}

\myparagraph{HTRS}
A \emph{higher-order term rewriting system} is a TRS with
\begin{itemize}
\item $\thSorts = \emptyset$
\item $\termsset = \Terms(\F,\V)$
\end{itemize}

\myparagraph{LC-HTRS}
A \emph{logically constrained higher-order term rewriting system} is a TRS with
\begin{itemize}
\item $\thSorts \neq \emptyset$
\item $\termsset = \Terms(\F,\V)$
\item $\order(\atype) \leq 1$ for all $(\afun :: \atype) \in \thF$
\item the constraint of each rule is a first-order term
\item the theory rules in $\Rules$ are exactly the calculation rules of the
  signature
\end{itemize}

\myparagraph{HTRS-T}
A \emph{higher-order term rewriting system with theories} is a TRS with
\begin{itemize}
\item $\thSorts \neq \emptyset$
\item $\termsset = \Terms(\F,\V)$
\end{itemize}

This is essentially the most general kind of TRS.

\subsection*{In Charlie}

\begin{itemize}
\item Generalised TRSs are represented by \texttt{charlie.trs.TRS}.
\item Both rules and generalised TRSs can be constructed using
  \texttt{charlie.trs.TrsFactory}.
  In particular, this factory offers ways to create specific, common kinds of
  TRSs like many-sorted or pattern TRSs.
\item To check whether a term $s$ is in the set $T_\F$ of a generalised TRS,
  one may use \texttt{trs.termAllowed($s$)}.
\item More typically, a TRS is created with specific restrictions on term
  creation, and what these are can be checked using
  \texttt{TRS::verifyProperties}.  This same function can be used to check
  which properties the rules and rule schemes in a TRS satisfy.
\end{itemize}

\newpage\appendix

\section{Correctness of the unconstrained formalism}

\subsection{$\alpha$-equality}

We first see that $=_\alpha$ is an equivalence relation (on terms, so also on true terms), so that
we can reason modulo it!

\begin{lemma}\label{lem:alphaequiv}
For all terms $s,t,q$, functions $\mu,\xi,\chi : \V \to \N$ and $k \in \N$:
\begin{enumerate}
\item\label{lem:alphaequiv:reflexive}
  $s =_\alpha^{\mu,\mu,k} s$;
\item\label{lem:alphaequiv:symmetric}
  if $s =_\alpha^{\mu,\xi,k} t$ then $t =_\alpha^{\xi,\mu,k} s$;
\item\label{lem:alphaequiv:transitive}
  if $s =_\alpha^{\mu,\xi,k} t$ and $t =_\alpha^{\xi,\chi,k} q$ then $s =_\alpha^{\mu,\chi,k} q$.
\end{enumerate}
\end{lemma}

\begin{proof}
All follow by a straightforward induction on the size of $s$. [Outcommented]
    % 
    % (\ref{lem:alphaequiv:reflexive})
    % If $s = h(s_1,\dots,s_n)$ with $n > 0$ then by IH both $h =_\alpha^{\mu,\mu,k}
    % h$ and $s_i  =_\alpha^{\mu,\mu,k} s_i$ for all $i$, which immediately gives $s
    % =_\alpha^{\mu,\mu,k} s$.
    % We similarly complete by the IH if $s = \meta{\avar}{t_1,\dots,t_k}$, and if
    % $s = \tuple{s_1}{s_n}$.
    % If $s = \afun \in \F$ or $\avar \in \Vfree$ the result is immediate.
    % If $s = \avar \in \Vbound$, then whether $\mu(\avar) = 0$ or $\mu(\avar) =
    % \mu(\avar) > 0$, $\avar =_\alpha^{\mu,\nu,k} \avar$ follows.
    % If $s = \abs{x}{t}$ then by IH $t =_\alpha^{\mu[x:=k],\mu[x:=k],k+1} t$; here also
    % $s =_\alpha^{\mu,\mu,k} s$ follows directly.
    %  
    % (\ref{lem:alphaequiv:symmetric})
    % If $s = a(s_1,\dots,s_n)$ with $n > 0$ then $t = b(t_1,\dots,t_n)$ with $a
    % =_\alpha^{\mu,\xi,k} b$  and $s_i =_\alpha^{\mu,\xi,k} t_i$ for all $i$; by IH
    % then $b =_\alpha^{\xi,\mu,k} a$ and $t_i =_\alpha^{\xi,\mu,k} s_i$ for all $i$,
    % so $t =_\alpha^{\xi,\mu,k} s$.
    % We similarly complete by IH if $s = \meta{\avar}{s_1,\dots,s_k}$ and
    % $t = \meta{\avar}{t_1,\dots,t_k}$, or if $s = \tuple{s_1}{s_n}$ and $t =
    % \tuple{t_1}{t_n}$.
    % If $s \in \F \cup \Vfree$ then $t = s$ and clearly also $t =_\alpha^{\xi,\mu,k}
    % s$.
    % If $s = \avar \in \Vbound$ then $t = \bvar \in \Vbound$ and $\mu(\avar) =
    % \xi(\bvar)$; either $\mu(\avar) = 0$ and $\bvar = \avar$ or $\mu(\avar) > 0$,
    % but in both cases $t =_\alpha^{\xi,\mu,k}$ holds.
    % If $s = \abs{x}{s'}$ then $t = \abs{y}{t'}$ and $s' =_\alpha^{\mu[x:=k],
    % \xi[y:=k],k+1} t'$. By IH also $t' =_\alpha^{\xi[y:=k],[x:=k],k+1} s'$.
    %  
    % (\ref{lem:alphaequiv:transitive})
    % If $s = a(s_1,\dots,s_n)$ with $n > 0$ then $t = b(t_1,\dots,t_n)$ and $q =
    % c(q_1,\dots,q_n)$ with $a =_\alpha^{\mu,\xi,k} b =_\alpha^{\xi,\chi,k} c$ and
    % $s_i =_\alpha^{\mu,\xi,k} t_i =_\alpha^{\xi,\chi,k} q_i$ for all $i$.  By IH
    % therefore $a =_\alpha^{\mu,\chi,k} c$ and $s_i =_\alpha^{\mu,\chi,k} q_i$ for
    % all $i$, allowing for the conclusion $s =_\alpha^{\mu,\chi,k} q$.
    % The cases $s = \meta{\avar}{s_1,\dots,s_k}$ and $s = \tuple{s_1}{s_n}$ follow
    % from IH in the same way.
    % If $s \in \F \cup \Vfree$ then $t = s$ and $q = s$, and $s =_\alpha^{\mu,\chi,k}
    % q$ follows directly.
    % If $s = \avar \in \Vbound$ and $\mu(\avar) = 0$ then $t = \avar$ and $\xi(\avar)
    % = 0$, and therefore $q = \avar$ and $\chi(\avar) = 0$; hence also $s
    % =_\alpha^{\mu,\chi,k} q$.
    % If $s = \avar \in \Vbound$ and $\mu(\avar) > 0$ then $t = \bvar \in \Vbound$ and
    % $\xi(\bvar) = \mu(\avar) > 0$, and therefore $q = \cvar \in \Vbound$ and
    % $\chi(\cvar) = \xi(\bvar) = \mu(\avar) > 0$.
    % Finally, if $s = \abs{\avar}{s'}$ then $t = \abs{\bvar}{t'}$ and $q =
    % \abs{\cvar}{q'}$, with $s' =_\alpha^{\mu[\avar:=k],\xi[\bvar:=k],k+1} t'
    % =_\alpha^{\xi[\bvar:=k],\chi[\cvar:=k],k+1} q'$.
    % By IH then $s' =_\alpha^{\mu[\avar:=k],\chi[cvar:=k],k+1} q'$.
\end{proof}

Choosing $k = 1$ and for $\mu,\xi,\chi$ the function mapping everything to $0$,
we obtain:

\begin{corollary}\label{corr:alphaequiv}
$=_\alpha$ is an equivalence relation.
\end{corollary}

As noted in the text, $\FV$ defines a function on equivalence classes:

\begin{lemma}\label{lem:alphafreevar}
If $s =_\alpha^{\mu,\xi,k} t$ then $\FV(s) \setminus \{ x \mid \mu(x) \neq 0 \} = \FV(t) \setminus \{ x \mid \xi(x) \neq 0 \}$.
\end{lemma}

\begin{proof}
By induction on the size of $s$.
All cases are straightforward. [Outcommented]
    % 
    % For brevity, we denote $M := \{ x \mid \mu(x) \neq 0 \}$ and $X :=  \{ x \mid
    % \xi(x) \neq 0 \}$.
    % \begin{itemize}
    % \item If $s = a(s_1,\dots,s_n)$ then $t = b(t_1,\dots,t_n)$ and both $a
    %   =_\alpha^{\mu,\xi,k} b$ and each $s_i =_\alpha^{\mu,\xi,k} t_i$.
    %   By the induction hypothesis, $\FV(a) \setminus M = \FV(b) \setminus X$ and
    %   $\FV(s_i) \setminus M = \FV(t_i) \setminus X$ for all $i$.
    %   Since $\FV(s) \setminus M = (\FV(a) \setminus M) \cup (\FV(s_1) \setminus M)
    %   \cup \dots \cup (\FV(s_n) \setminus M)$ for any set $M$, and similar for
    %   $\FV(t) \setminus X$, we are done.
    % \item If $s = \afun$ then $t = \afun$ and both sets are empty.
    % \item If $s = \avar \in \Vfree$ then $t = \avar$ and both sets are $\{\avar\}$.
    % \item If $s = \avar \in \Vbound$ and $\mu(\avar) = 0$ then $t = \avar$ and
    %   $\xi(\avar) = 0$ as well.  Therefore $\avar \notin M$ and $\avar \notin X$.
    %   Hence $\FV(s) \setminus M = \{ x \} = \FV(t) \setminus X$.
    % \item If $s = \avar \in \Vbound$ and $\mu(\avar) > 0$ then $t = \bvar \in
    %   \Vbound$ and $\xi(\bvar) = mu(\avar) > 0$ as well.  Therefore $\avar \in M$
    %   and $\bvar \in X$.
    %   Hence $\FV(s) \setminus M = \emptyset = \FV(t) \setminus X$.
    % \item If $s = \abs{x}{s'}$ then $t = \abs{y}{t'}$ and $s' =_\alpha^{\mu[x:=k],
    %   \xi[y:=k],k+1} t'$.  We have $\FV(s) \setminus M = (\FV(s') \setminus \{ x \})
    %   \setminus M = \FV(s') \setminus \{ z \mid \mu[x:=k](z) \neq 0 \}$.  Moreover,
    %   $\FV(t) \setminus X = \FV(t') \setminus \{ z \mid \xi[y:=k](z) \neq 0 \}$.
    %   We complete again by the induction hypothesis.
    % \item If $s = \meta{\Bvar}{s_1,\dots,s_n}$ and $t = \meta{\Bvar}{t_1,\dots,t_n}$,
    %   of if $s = \tuple{s_1}{s_n}$ and $t = \tuple{t_1}{t_n}$, then
    %   then $\FV(s) \setminus M = (\FV(s_1) \cup \dots \FV(s_k)) \setminus M =
    %   (\FV(s_1) \setminus M) \cup \dots \cup (\FV(s_n) \setminus M)$, which by the
    %   induction hypothesis is equal to $(\FV(t_1) \setminus X) \cup \dots \cup
    %   (\FV(t_n) \setminus X) = \FV(t) \setminus X$.
    %   \qedhere
    % \end{itemize}
\end{proof}

And similarly, $\FMV$ defines a function on equivalence classes as well.

\begin{lemma}\label{lem:alphamvar}
If $s =_\alpha^{\mu,\xi,k} t$ then $\FMV(s) = \FMV(t)$.
\end{lemma}

\begin{proof}
By induction on the size of $s$.
All cases are straightforward. [Outcommented]
    % 
    % \begin{itemize}
    % \item If $s = a(s_1,\dots,s_n)$ then $t = b(t_1,\dots,t_n)$ and both $a
    %   =_\alpha^{\mu,\xi,k} b$ and each $s_i =_\alpha^{\mu,\xi,k} t_i$.
    %   By the induction hypothesis, $\FMV(a) = \FMV(b)$ and $\FMV(s_i) = \FMV(t_i)$
    %   for all $i$.
    %   Since $\FMV(s) = \FMV(a) \cup \FMV(s_1) \cup \dots \cup \FMV(s_n)$, and
    %   similar for $\FMV(t)$, we are done.
    % \item We are similarly done quickly if $s = \tuple{s_1}{s_n}$ and $t =
    %   \tuple{t_1}{t_n}$.
    % \item If $s = \afun$ then $t = \afun$ and both sets are empty.
    % \item If $s = \avar \in \Vfree$ then $t = \avar$ and both sets are $\{\avar\}$.
    % \item If $s = \avar \in \Vbound$ then also $t \in \Vbound$, and both sets are
    %   $\emptyset$.
    % \item If $s = \abs{x}{s'}$ then $t = \abs{y}{t'}$ and $s' =_\alpha^{\mu[x:=k],
    %   \xi[y:=k],k+1} t'$.  We have $\FMV(s) = \FMV(s')$ and $\FMV(t) = \FMV(t')$,
    %   and by the induction hypothesis these are equal.
    % \item If $s = \meta{\Bvar}{s_1,\dots,s_n}$ and $t = \meta{\Bvar}{t_1,\dots,t_n}$,
    %   then $\FMV(s) = \{\Bvar\} \cup \FMV(s_1) \cup \dots \cup \FMV(s_n)$ and
    %   $\FMV(t) = \{\Bvar\} \cup \FMV(t_1) \cup \dots \cup \FMV(t_n)$.  We complete
    %   once more by induction on each $s_i$.
    %   \qedhere
    % \end{itemize}
\end{proof}

Choosing $k = 1$ and $\mu,\xi$ the constant $0$-functions again, we obtain:

\begin{corollary}\label{corr:alphafreevar}
If $s =_\alpha t$ then $\FV(s) = \FV(t)$ and $\FMV(s) = \FMV(t)$.
\end{corollary}

Well-formedness is formally obtained by the following Lemma:

\begin{lemma}\label{lem:wellformedcounterpart}
Let $X \subseteq \Vbound$ be finite, and let $s$ be a term, $k \in \N$ and
$\mu,\xi$ be functions in $\Vbound \to \{0,\dots,k\}$ such that:
\begin{itemize}
\item for every $i \in \{1,\dots,k\}$, there is exactly one variable $\bvar$
  such that $\xi(\bvar) = i$
\item for $\avar \in \FV(s)$: if $\mu(\avar) = 0$ then $\xi(\avar) = 0$
\item all $\avar$ with $\mu(\avar) > 0$ and all $\bvar$ with $\xi(\bvar) > 0$
  are in $X$
\end{itemize}
Then there exists a well-formed term $t$ such that $s =_\alpha^{\mu,\xi,k+1} t$
and $\BV(t) \cap X = \emptyset$.
\end{lemma}

\begin{proof}
By a straightforward induction on the size of $s$.  To ensure that in all
subterms, $\FV(t) \cap \BV(t) = \emptyset$, we start by including $\FV(s)$ into
$X$.
    % 
    % \begin{itemize}
    % \item If $s = \afun$ then we can choose $t = \afun$ as well.
    % \item If $s = \avar$ with $\mu(\avar) = 0$ then note that $\avar \in \FV(s)$ so
    %   by assumption $\xi(\avar) = 0$ as well.  We choose $t = \avar$.
    % \item If $s = \avar$ with $\mu(\avar) = i > 0$, then let $\bvar$ be the unique
    %   variable such that $\xi(\bvar) = i$ (this exists by assumption).  We choose
    %   $t = \bvar$.
    % \item If $s = a(s_1,\dots,s_n)$ with $n > 0$ then by the induction there exist
    %   well-formed $b$, $t_1,\dots,t_n$ such that $a =_\alpha^{\mu,\xi,k+1} b$ and
    %   $\BV(b) \cap X = \emptyset$, and $s_i =_\alpha^{\mu,\xi,k+1} t_i$ for all
    %   $i$, and $\BV(t_i) \cap X = \emptyset$.  Note that by definition of
    %   $\alpha$-equivalence, $b$ cannot be an application because $a$ is not, so
    %   $t := b(t_1,\dots,t_n)$ is a term, and $s =_\alpha^{\mu,\xi,k+1} t$.
    % 
    %   Note that $\BV(t) \cap X =
    %   (\BV(b) \cup \BV(t_1) \cup \dots \cup \BV(t_n)) \cap X =
    %   (\BV(b) \cap X) \cup (\BV(t_1) \cap X) \cup \dots \cup (\BV(t_n) \cap X) =
    %   \emptyset$.
    % 
    %   We also observe that $\FV(t) \cap \BV(t) = \emptyset$: towards a
    %   contradiction assume that $\cvar \in \FV(t) \cap\BV(t)$.  If $\xi(\cvar) = 0$
    %   then note that by Lemma~\ref{lem:alphafreevar}, also $\cvar \in \FV(s)$ and
    %   therefore in $X$ (as we had assumed $X \supseteq \FV(s)$), and we observed
    %   above that $\BV(t) \cap X = \emptyset$.  On the other hand, if
    %   $\xi(\cvar) > 0$ then $\cvar \in X$ by assumption.
    %   Hence, from this and well-formedness of $b$ and all $t_i$, we conclude that
    %   $t$ is well-formed.
    % \item If $s = \tuple{s_1}{s_n}$ or $\meta{\Cvar}{s_1,\dots,s_n}$ then we use
    %   the induction hypothesis to find well-formed $t_1,\dots,t_n$ such that each
    %   $s_i =_\alpha^{\mu,\xi,k+1} t_i$ and $\BV(t_i) \cap X = \emptyset$.  We
    %   choose $t := \tuple{t_1}{t_n}$ or $\meta{\Cvar}{t_1,\dots,t_n}$ respectively,
    %   which suffices with the same reasoning we used above.
    % \item Finally, if $s = \abs{\avar}{s'}$ then note that, since $X$ is finite and
    %   there are infinitely many binder variables of all types, we can choose
    %   $\bvar \notin X$ which has the same type as $\avar$.
    %   Let $\mu' := \mu[\avar:=k+1]$,
    %   let $\xi' := \xi[\bvar:=k+1]$,
    %   and let $X' := X \cup \{\avar,\bvar\}$;
    %   then still $X' \supseteq \FV(s')$ and $X'$ contains all variables $\cvar$
    %   with $\mu'(\cvar) > 0$ or $\xi'(\cvar) > 0$.  The other two requirements to
    %   apply the induction hypothesis are also satisfied, so we do so and find a
    %   well-formed term $t'$ such that $s' =_\alpha^{\mu',\xi',k+2} t'$, and $\BV(t)
    %   \cap X' = \emptyset$.
    % 
    %   Let $t := \abs{\bvar;}{t'}$.
    %   Then we see: $\BV(t) \cap X = (\BV(t') \cup \{\bvar\}) \cap X =  (\BV(t')
    %   \cap X) \cup (\{\bvar\} \cap X) = \BV(t') \cap X \subseteq \BV(t') \cap X' =
    %   \emptyset$.
    %   Moreover, $\FV(t) \cap \BV(t) = (\FV(t') \setminus \{\bvar\}) \cap
    %   (\BV(t') \cup \{\bvar\}) = \FV(t') \cap \BV(t') = \emptyset$ because $t'$ is
    %   well-formed.
    %   Since $\bvar \notin \BV(t')$ (as $\bvar \in X'$), this tells us that $t$ is
    %   well-formed.
    %   \qedhere
    % \end{itemize}
\end{proof}

By choosing $k = 1$ we immediately obtain:

\begin{corollary}\label{cor:wellformedcounterpart}
If $X \subseteq \Vbound$ is finite then for every term $s$ there exists a
well-formed term $t$ such that $s =_\alpha t$ and $\BV(t) \cap X = \emptyset$.
\end{corollary}

Next, we define some helper results that have little meaning on their own, but
will prove useful when reasoning about $\alpha$-equivalence (especially in
combination with substitution).

\begin{lemma}\label{lem:alphaincrease}
Let $\mu,\xi$ be such that $\mu(\avar) < k$ and $\xi(\avar) < k$ for all
$\avar \in \Vbound$. \\
Then if $s =_\alpha^{\mu,\xi,k} t$ we have $s =_\alpha^{\mu,\xi,k+1} t$.
\end{lemma}

\begin{proof}
For an integer $0 < n \leq k$, let:
\[\mathit{up}_n(i) = \left\{
\begin{array}{ll}
i & \text{if}\ i \leq n\ \text{or}\ i \geq k+1 \\
i+1 & \text{if}\ n < i \leq k \\
\end{array}
\right.
\]
Let $\mu_n(x) = \mathit{up}_n(\mu(x))$ and $\xi_n(x) = \mathit{up}_n(x)$.
We will prove by induction on $s$ that for fixed $n > 0$, all $k \geq n$:
if $s =_\alpha^{\mu,\xi,k} t$ then $s =_\alpha^{\mu_n,\xi_n,k+1} t$.
The result then follows by choosing $n = k$, since $\mathit{up}_k$ is the
identity and therefore $\mu_k = \mu$ and $\xi_k = \xi$.
The proof is straightforward. We only show the most difficult case.
[The rest is outcommented]

\begin{itemize}
    % \item If $s = a(s_1,\dots,s_m)$ then $t = b(t_1,\dots,b_m)$ with
    %   $a =_\alpha^{\mu,\xi,k} b$ and each $s_i =_\alpha^{\mu,\xi,k} t_i$.
    %   By the IH, $a =_\alpha^{\mu_n,\xi_n,k+1} b$ and each
    %   $s_i =_\alpha^{\mu_n,\xi_n,k+1} t_i$; hence, the result follows.
    % \item If $s = \meta{\Avar}{s_1,\dots,s_m}$ or $s = \tuple{s_1}{s_m}$, the result
    %   follows similarly easily.
    % \item If $s = \afun$ or $s = \avar \in \Vfree$, then $t = s$ and the result
    %   immediately follows.
    % \item If $s = \avar \in \Vbound$ and $\mu(\avar) = 0$ then $t = \avar$ and
    %   $\xi(\avar) = 0$; then also $\mu_n(\avar) = \xi_n(\avar) = 0$, and we are
    %   done.
    % \item If $s = \avar \in \Vbound$ and $\mu(\avar) > 0$ then $t = \bvar \in
    %   \Vbound$ and $\xi(\avar) = \mu(\avar) > 0$.  But then, whatever the value of
    %   $\mu(\avar)$, we have that $\mu_n(\avar) = \mathit{up}_n(\mu(\avar)) =
    %   \mathit{up}_n(\xi(\bvar)) = \xi_n(\avar)$ as well, giving the required result.
\item If $s = \abs{x}{s'}$ then $t = \abs{y}{t'}$ and $s' =_\alpha^{\mu[x:=k],
  \xi[y:=k],k+1} t'$.
  Write $\mu' := \mu[x:=k]$ and $\xi' := \xi[y:=k]$. Then we have:
  \begin{itemize}
  \item for all variables $z$: $\mu'(z) < k+1$ (since either $\mu'(z) = \mu(z)
    < k$, or $\mu'(z) = k$ if $z = x$);
  \item for all variables $z$: $\xi'(z) < k+$ (by the same reasoning);
  \item $k+1 > k \geq n$. \\
  \end{itemize}
  Hence, we can apply the induction hypothesis, to deduce: $s' =_\alpha^{\mu'_n,
  \xi'_n,k+2} t'$.

  But now observe that $\mu'_n = \mu_n[x:=k+1]$:
  \begin{itemize}
  \item for $z \neq x$: $\mu'_n(z) = \mathit{up}_n(\mu'(z)) =
    \mathit{up}_n(\mu(z)) = \mu_n(z) = \mu_n(z)[x:=k+1]$
  \item for $z = x$: $\mu'_n(z) = \mathit{up}_n(\mu'(z)) = \mathit{up}_n(k) =
    k+1 = \mu_n[x:=k+1](x)$. \\
  \end{itemize}
  And similarly, $\xi'_n = \xi_n[y:=k+1]$.

  So we have: $s' =_\alpha^{\mu_n[x:=k+1],\xi_n[y:=k+1],k+2} t'$, which
  exactly gives $s =_\alpha^{\mu_n,\xi_n,k+1} t$.
  \qedhere
\end{itemize}
\end{proof}

\begin{lemma}\label{lem:alphaunusedvar}
Suppose $s =_\alpha^{\mu,\xi,k} t$ and $\mu'(x) = \mu(x)$ for all $x \in \FV(s)$, and $\xi'(y) = \xi(y)$ for all $y \in \FV(t)$.
Then $s =_\alpha^{\mu',\xi',k} t$.
\end{lemma}

\begin{proof}
By induction on the size of $s$.
All cases are straightforward. [Outcommented]
    % \begin{itemize}
    % \item If $s = a(s_1,\dots,s_n)$ then $t = b(t_1,\dots,t_n)$ and
    %   $a =_\alpha^{\mu,\xi,k} b$ and each $s_i =_\alpha^{\mu,\xi,k} t_i$.
    %   By the induction hypothesis, $a =_\alpha^{\mu',\xi',k} b$ and each $s_i
    %   =_\alpha^{\mu',\xi',k} t_i$.
    %   This immediately gives $s =_\alpha^{\mu',\xi',k} t$ as required.
    % \item We similarly conclude immedately if $s = \meta{\ameta}{t_1,\dots,t_k}$ or
    %   $s = \tuple{s_1}{s_n}$.
    % \item If $s = \afun$ or $s = x \in \Vfree$ then $t = s$ and the result
    %   immediately follows.
    % \item If $s = \avar \in \Vbound$ and $\mu(\avar) = 0$ then $t = \avar$ and 
    %   $\xi(\avar) = 0$.  Since clearly $\avar \in \FV(s)$ and $\avar \in \FV(t)$ we
    %   have $\mu'(x) = \xi'(y) = 0$ as well.
    %   Hence indeed $s =_\alpha^{\mu',\xi',k} t$.
    % \item If $s = \avar \in \Vbound$ and $\mu(\avar) > 0$ then $t = \bvar \in
    %   \Vbound$ and $\xi(\bvar) > 0$.  Since clearly $\avar \in \FV(s)$ and $\bvar
    %   \in \FV(t)$ we have $\mu'(\avar) = \mu(\avar) = \xi(\bvar) = \xi'(\bvar) > 0$
    %   as well.
    % \item If $s = \abs{x}{s'}$ then $t = \abs{y}{t'}$ and $s' =_\alpha^{\mu[x:=k],\
    %   xi[y:=k],k+1} t'$.  Now, for all $z \in \FV(s')$: either $z = x$ and
    %   $\mu'[x:=k](z) = k = \mu[x:=k](z)$, or $z \in \FV(s)$ and $\mu[x:=k](z) =
    %   \mu(z) = \mu'(z) = \mu'[x:=k](z)$ by assumption.
    %   Similarly, for all $z \in \FV(t')$ we have $\xi'[y:=k](z) = \xi[y:=k](z)$.
    %   Hence we can apply the induction hypothesis on $s'$ to obtain
    %   $s' =_\alpha^{\mu'[x:=k],\xi'[y:=k],k+1} t'$.
    %   This immediately implies $s =_\alpha^{\mu',\xi',k} t$.
    %   \qedhere
    % \end{itemize}
\end{proof}

We also observe that $\alpha$-equality interacts well with application:

\begin{lemma}\label{lem:alphaappl}
Let $s = u \cdot s_1 \cdots s_n$ and $t = v \cdot t_1 \cdots t_n$.
Then $s =_\alpha^{\mu,\xi,k} t$ if and only if $u =_\alpha^{\mu,\xi,k} v$ and
$s_i =_\alpha^{\mu,\xi,k} t_i$ for $1 \leq i \leq n$.
\end{lemma}

\begin{proof}
This is easily seen by inspecting the definitions.
    % 
    % First suppose $u =_\alpha^{\mu,\xi,k} v$ and each $s_i =_\alpha^{\mu,\xi,k}
    % t_i$.  Consider the form of $u$; we can always write $u = a(u_1,\dots,u_m)$
    % with $m \geq 0$, and since $u =_\alpha^{\mu,\xi,k} v$, necessarily $v = b(v_1,
    % \dots,v_m)$ with $a =_\alpha^{\mu,\xi,k} b$ and each $u_i =_\alpha^{\mu,\xi,k}
    % v_i$.  But then $s = a(u_1,\dots,u_m,s_1,\dots,s_n)$ and $t = b(v_1,\dots,v_m,
    % t_1,\dots,t_n)$; it immediately follows that $s =_\alpha^{\mu,\xi,k} t$.
    % 
    % Alternatively, suppose that $s =_\alpha^{\mu,\xi,k} t$.  Again denote $u =
    % a(u_1,\dots,u_m)$.  Then necessarily $s = a(u_1,\dots,u_m,s_1,\dots,s_n)$.  Also
    % write $v = b(v_1,\dots,v_k)$; then $t = b(v_1,\dots,v_k,t_1,\dots,t_n)$.  But by
    % definition of $s =_\alpha^{\mu,\xi,k} t$ necessarily $m + n = k + n$; that is,
    % $m = k$.  Moreover, necessarily $a =_\alpha^{\mu,\xi,k} b$, each $u_i
    % =_\alpha^{\mu,\xi,k} b$, and each $s_i =_\alpha^{\mu,\xi,k} t_i$.  But then
    % also $u = a(u_1,\dots,u_m) =_\alpha^{\mu,\xi,k} b(v_1,\dots,v_m) = v$.
\end{proof}

\subsection{Well-definedness of substitution}

\newcommand{\subrel}[1]{\mathsf{subst}(#1)}

To avoid the suggestive equality notation, we will reformulate the notion of
substitution as a relation.  First, let us abuse notation and write
$\gamma(x) = x$ for all variables $x \notin \domain(\gamma)$.  We now let
substitution be the smallest relation generated by the following rules:

\begin{enumerate}
\item\label{subst:func} $\subrel{\afun,\gamma,\afun}$
\item\label{subst:var} $\subrel{\avar,\gamma,\gamma(\avar)}$ (which is now
  defined whether $\avar \in \domain(\gamma)$ or not)
\item\label{subst:appl} $\subrel{h(s_1,\dots,s_n), \gamma, u \cdot t_1 \cdots
  t_n)}$ if $\subrel{h,\gamma,u}$ and $\subrel{s_i,\gamma,t_i}$ for
  $1 \leq i \leq n$;
\item\label{subst:tuple} $\subrel{\tuple{s_1}{s_n},\gamma,\tuple{t_1}{t_n}}$ if
  $\subrel{s_i,\gamma,t_i}$ for $1 \leq i \leq n$;
\item\label{subst:abs} $\subrel{\abs{\avar}{s},\gamma,\abs{\cvar}{q}}$ if
  $\cvar$ has the same type as $\avar$ and:
  \begin{itemize}
  \item $\cvar \notin \FV(\gamma(\bvar))$ for any $\bvar \in
    \FV(\abs{\avar}{s}) \cup (\FMV(\abs{\avar}{s}) \cap \domain(\gamma))$
  \item $\subrel{s,[\avar:=\cvar] \cup [\bvar := \gamma(\bvar) \mid \bvar \in
    \domain(\gamma) \setminus \{\avar\}],q}$.
  \end{itemize}
\item\label{subst:boringmeta} $\subrel{\meta{\Avar}{s_1,\dots,s_n},\gamma,
  \meta{\Avar}{t_1,\dots,t_n}}$ if $\Avar \notin \domain(\gamma)$ and
  $\subrel{s_1,\gamma,t_i}$ for $1 \leq i \leq n$
\item\label{subst:meta} $\subrel{\meta{\Avar}{s_1,\dots,s_n},\gamma,q}$ if
  $\Avar \in \domain(\gamma)$ and $\gamma(\Avar) = \abs{\bvar_1 \dots \bvar_n}{
  t}$ and there exist $t_1,\dots,t_n$ such that:
  \begin{itemize}
  \item $\subrel{s_i,\gamma,t_i}$ for $q \leq i \leq n$
  \item $\subrel{t,[\bvar_1:=t_1,\dots,\bvar_n:=t_n],q}$
  \end{itemize}
\end{enumerate}
It is easy to see that this defines the same relation as substitution in the
main text.  The ``smallest'' relation with these properties is well-defined
because the definition can be seen as a fixpoint: any additional relation
$\subrel{s,\gamma,t}$ that is discovered cannot change the relations that were
previously discovered.
Beyond that, we have:

\begin{lemma}\label{lem:substdefined}
For every term $s$ and substitution $\gamma$ there exists $q$ with
$\subrel{s,\gamma,q}$.
\end{lemma}

\begin{proof}
We first prove that the lemma holds when limited to $\gamma$ where
$\domain(\gamma) \subseteq \Vbound$; this follows by a straightforward induction
on the size of $s$ because in the meta-application case $\meta{\Avar}{s_1,\dots,
s_k}$, the meta-variable $\Avar$ is not in $\domain(\gamma)$.
Having this property, the full lemma follows, again by induction on the size of
$s$: the final case where $s = \meta{\Avar}{s_1,\dots,s_k}$ follows by
observing that we have already proved the existence of some $q$ with
$\subrel{t,[\bvar_1:=t_1,\dots,\bvar_n:=t_n],q}$ in the first step.

We first consider the lemma statement limited to $\gamma$ where
$\domain(\gamma) \subseteq \Vbound$.  This we prove by induction on the size of
$s$.  Consider the form of $s$:
\begin{itemize}
\item If $s = \afun$ we can choose $q := \afun$.
\item If $s = \avar$ we can choose $q := \gamma(\avar)$.
\item If $s = h(s_1,\dots,s_n)$ with $n > 0$ then by the induction hypothesis
  there exist $u$ such that $\subrel{h,\gamma,u}$ and $t_1,\dots,t_n$ such that
  $\subrel{s_i,\gamma,t_i}$ for all $i$.  As application (the $\cdot$ operator)
  is unambiguously defined, we can choose $q := u \cdot t_1 \cdots t_n$.
\item If $s = \tuple{s_1}{s_n}$ then by the induction hypothesis there exist
  $u_1,\dots,u_n$ such that $\subrel{s_i,\gamma,u_i}$ for all $i$; we can
  choose $q := \tuple{u_1}{u_n}$.
\item If $s = \abs{\avar}{s'}$ then first note that a suitable $\cvar$ can
  always be found, as $\Vbound$ has infinitely many variables of all types and
  $\bigcup_{\bvar \in \FV(s)} \FV(\gamma(\bvar))$ is finite.  Then, writing
  $\delta := [\avar:=\cvar] \cup [\bvar:=\gamma(\bvar) \mid \bvar \in
  \domain(\gamma) \setminus \{\avar\}]$, there exists $q'$ such that
  $\subrel{s',\delta,q'}$ by the induction hypothesis on $s'$.  We complete with
  $q := \abs{\cvar}{q}$.
\item If $s = \meta{\Avar}{s_1,\dots,s_k}$, then by the induction hypothesis we
  find $t_1,\dots,t_k$ with $\subrel{s_i,\gamma,t_i}$ for all $i$.  Since, by
  assumption, $\Avar \notin \domain(\gamma)$, we can choose $q :=
  \meta{\Avar}{t_1,\dots,t_k}$.
\end{itemize}
Next, we prove the full lemma statement. The cases where $s$ is a constant,
variable, application, tuple or abstraction are exactly the same as above, as is
the case when $s = \meta{\Avar}{s_1,\dots,s_k}$ with $\Avar \notin \domain(
\Avar)$.  So assume $s = \meta{\Avar}{s_1,\dots,s_k}$ with $\Avar \in
\domain(\Avar)$; then by definition of substitution we can write
$\gamma(\Avar) = \abs{\bvar_1 \dots \bvar_k}{t}$.  By the induction hypothesis
there exist $t_1,\dots,t_k$ such that $\subrel{s_i,\gamma,t_i}$; let $\delta :=
[\bvar_1:=t_1,\dots,\bvar_k:=t_k]$.  The domain of $\delta$ only contains
variables in $\Vbound$, so by the limited lemma statement, there exists $q$
such that $\subrel{t,\delta,q}$.  But then $\subrel{s,\gamma,q}$ holds.
\end{proof}

Towards the second result for well-definedness, that substitution defines a
function on equivalence classes, we specify the following lemma.  This is
formulated more generally than we need to obtain an easier induction.

\begin{lemma}\label{lem:substitutionalpha}
Let $k$ be an integer, and $\nu,\chi : \Vbound \mapsto \{0,\dots,k\}$.
Assume given terms $s,s'$, an integer $p$, mappings $\mu,\xi : \Vbound \mapsto
\{0,\dots,p\}$ and substitutions $\gamma,\gamma'$ such that:
\begin{itemize}
\item for all $x \in \FV(s)$ with $\mu(x) = 0$ we have:
  $\gamma(x) =_\alpha^{\nu,\chi,k+1} \gamma'(x)$
\item for all $x \in \FV(s)$, $y \in \FV(s')$ such that $\mu(x) = \xi(y) > 0$
  we have: $\gamma(x) =_\alpha^{\nu,\chi,k+1} \gamma'(y)$
\item $\domain(\gamma) \cap \M = \domain(\gamma') \cap \M$ and
  $\gamma(\Avar) =_\alpha^{\nu,\chi,k+1} \gamma'(\Avar)$ for all
  $\Avar \in \domain(\gamma) \cap \M$
\item $s =_\alpha^{\mu,\xi,p+1} s'$
\end{itemize}
Assume given $t,t'$ such that $\subrel{s,\gamma,t}$ and $\subrel{s',\gamma',
t'}$.  Then we have $t =_\alpha^{\nu,\chi,k+1} t'$.
\end{lemma}

\begin{proof}
We prove the statement by induction on the definition of $\subrel$ (so, on the
proof of Lemma \ref{lem:substdefined}).
Although the proof is not overly complex, it is quite long, and requires
multiple applications of both Lemmas \ref{lem:alphafreevar} and
\ref{lem:alphaappl}, as well as an application of both Lemmas
\ref{lem:alphaincrease} and \ref{lem:alphaunusedvar}.
    % 
    % Consider the shape of $s$.
    % \begin{itemize}
    % \item Suppose $s = \afun$.  Then $s' = t = t' = \afun$ and indeed
    %   $t =_\alpha^{\nu,\chi,k+1} t'$.
    % \item Suppose $s = \avar$ with $\mu(\avar) = 0$.  Then $s' = \avar$ and $t =
    %   \gamma(x) =_\alpha^{\nu,\chi,k+1} \gamma'(x) = t'$ by assumption.
    % \item Suppose $s = \avar$ with $\mu(\avar) > 0$.  Then $s' = \bvar$ with
    %   $\xi(\bvar) = \mu(\avar)$, so also by assumption $t = \gamma(x)
    %   =_\alpha^{\nu,\chi,k+1} \gamma'(y) = t'$.
    % \item Suppose $s = h(s_1,\dots,s_n)$ with $n > 0$.
    %   Then $s' = h'(s_1',\dots,s_n')$ with $h =_\alpha^{\mu,\xi,p+1} h'$ and $s_i
    %   =_\alpha^{\mu,\xi,p+1} s_i'$ for all $i$. \\
    %   From $\subrel{s,\gamma,t}$ we obtain: $t = u \cdot t_1 \cdots t_n$ with
    %   $\subrel{h,\gamma,u}$ and $\subrel{s_i,\gamma,t_i}$ for all $i$.
    %   From $\subrel{s',\gamma',t'}$ we obtain: $t' = u' \cdot t_1' \cdots t_n'$ with
    %   $\subrel{h',\gamma',u'}$ and $\subrel{s_i',\gamma',t_i'}$ for all $i$. \\
    %   Hence, by the induction hypothesis on $\subrel{h,\gamma,u}$ and $\subrel{h',
    %   \gamma',u'}$ we have: $u =_\alpha^{\nu,\chi,k+1} u'$.
    %   Similarly, by the IH on each $\subrel{s_i,\gamma,t_i}$ and $\subrel{s_i',
    %   \gamma',t_i'}$ we have: $t_i =_\alpha^{\nu,\chi,k+1} t_i'$. \\
    %   By Lemma \ref{lem:alphaappl} we obtain the required conclusion
    %   $t =_\alpha^{\nu,\chi,k+1} t'$.
    % \item Suppose $s = \tuple{s_1}{s_n}$.  Then we complete in the same way.
    % \item Suppose $s = \meta{\Avar}{s_1}{s_k}$ with $\Avar \notin \domain(\gamma)$.
    %   Then also $\Avar \notin \domain(\gamma')$ since $\domain(\gamma) \cap \M =
    %   \domain(\gamma') \cap \M$ by assumption.  Hence, we again complete as above.
    % \item Suppose $s = \abs{x}{u}$. Then $s' = \abs{x'}{u'}$ and
    %     $t = \abs{z}{q}$ and $t' = \abs{z'}{q'}$, where:
    %   \begin{itemize}
    %   \item $u =_\alpha^{\mu[x:=p+1],\xi[x':=p+1],p+2} u'$;
    %   \item $z \notin \FV(\gamma(y))$ for any $y \in \FV(s)$ and
    %     $z' \notin \FV(\gamma'(y))$ for any $y \in \FV(s')$;
    %   \item $\subrel{u,[x:=z] \cup [y:=\gamma(y) \mid y \in \domain(\gamma)
    %     \setminus \{x\},q}$ and \\
    %     $\subrel{u',[x':=z'] \cup [y:=\gamma'(y) \mid y \in \domain(\gamma')
    %     \setminus \{x'\},q'}$. \\
    %   \end{itemize}
    %   Now, let $\delta := [x:=z] \cup [y:=\gamma(y) \mid y \in \domain(\gamma)
    %   \setminus \{ x \}]$ and $\delta' := [x':=z'] \cup [y:=\gamma'(y) \mid y \in
    %   \domain(\gamma') \setminus \{ x' \}]$, so we have
    %   $\subrel{u,\delta,q}$ and $\subrel{u',\delta',q'}$.
    %   Let $\mu_b := \mu[x:=p+1]$ and $\xi_b := \xi[x':=p+1]$ and $\nu_b :=
    %   \nu[z:=k+1]$ and $\chi_b := \chi[z':=k+1]$.
    %   We apply the induction hypothesis on $\subrel{u,\delta,q}$ and $\subrel{u',
    %   \delta',q'}$. (**)
    %   This gives us that $q =_\alpha^{\nu_b,\chi_b,k+2} q'$, and therefore $t =
    %   \abs{z}{q} =_\alpha^{\nu,\chi,k+1} \abs{z'}{q'} = t'$ as required.
    % 
    %   (**) To see that we may apply the induction hypothesis to obtain this
    %   conclusion, we observe that $\nu_b,\chi_b$ are functions in $\Vbound \to
    %   \{0,\dots,k+1\}$, that $\mu_b,\xi_b$ are functions in $\Vbound \to \{0,\dots,
    %   p+1\}$, and that $u =_\alpha^{\mu_b,\xi_b,p+2} u'$ as observed above.
    %   For the substitutions, we must show that for all $y \in \FV(u)$:
    %   \begin{itemize}
    %   \item if $\mu_b(y) = 0$ then $\delta(y) =_\alpha^{\nu_b,\chi_b,k+2}
    %     \delta'(y)$;
    %   \item if $\mu_b(y) > 0$ and $y' \in \FV(u')$ is such that $\mu_b(y) =
    %     \xi_b(y')$ then $\delta(y) =_\alpha^{\nu_b,\chi_b,k+2} \delta'(y')$. \\
    %   \end{itemize}
    %   So let $y \in \FV(u)$; if $\mu_b(y) = 0$ then let $y' := y$, otherwise let $y'$ be such that $\mu_b(y) = \xi_b(y')$.
    % 
    %   If $y = x$, then $\mu_b(y) = p + 1$, so we should show the second case.
    %   Since $\xi$ maps to $\{0,\dots,p\}$ and $\xi_b(x') = p + 1$, necessarily $y' =
    %   x'$.
    %   Hence we must show: $z = \delta(x) =_\alpha^{\nu_b,\chi_b,k+2} \delta'(x') = z'$.
    %   Since $\nu_b(z) = k + 1 = \chi_b(z')$ this clearly holds.
    % 
    %   Alternatively, if $y \neq x$, then $\mu_b(y) = \mu(y) \leq p$.
    %   \begin{itemize}
    %   \item If $\mu_b(y) > 0$ and $y' \in \FV(u')$ has $\mu_b(y) = \xi_b(y')$, then
    %     note that $y' \neq x'$, as $\xi_b(x') = p+1 > \mu_b(y)$.
    %     Hence, $\xi_b(y') = \xi(y')$.
    %   \item Otherwise, $y' = y$ by definition and since $y \in \FV(u) \setminus
    %     \{ x \} = \FV(s)$ we can apply Lemma \ref{lem:alphafreevar} to obtain $y \in
    %     \FV(s')$ and $\xi(y) = 0$; so $y \in \FV(u')$ and $y \neq x'$, hence
    %     $\xi_b(y) = \xi(y) = 0$.\\
    %   \end{itemize}
    %   Hence, either way, $y' \neq x'$ and $\xi_b(y') = \xi(y')$.
    %   Then also $\delta(y) = \gamma(y)$ and $\delta'(y') = \gamma'(y')$, and by the
    %   assumptions on $\gamma,\gamma'$ we have:
    %   $\delta(y) =_\alpha^{\nu,\chi,k+1} \delta'(y)$.
    %   Hence by Lemma \ref{lem:alphaincrease}, $\delta(y) =_\alpha^{\nu,\chi,k+2}
    %   \delta'(y)$ (*A). \\
    %   Now, since $y \in \FV(u)$ and $y \neq x$, we have $y \in \FV(s)$.  Similarly,
    %   $y' \in \FV(s')$.
    %   By the freshness condition on $z,z'$ we have: $z \notin \FV(\gamma(y)) =
    %   \FV(\delta(y))$, and $z' \notin \FV(\delta'(y'))$.
    %   But then by (*A) and Lemma \ref{lem:alphaunusedvar},
    %   $\delta(w) =_\alpha^{\nu_b,\chi_b,k+2} \delta'(w')$ as required.
    % \item Finally, suppose $s = \meta{\Avar}{s_1,\dots,s_m}$ with $\Avar \in
    %   \domain(\gamma)$.  Then:
    %   \begin{itemize}
    %   \item $s' = \meta{\Avar}{s_1',\dots,s_m'}$ with $s_i =_\alpha^{\mu,\xi,p+1}
    %     s_i'$ for all $i$;
    %   \item $\Avar \in \domain(\gamma')$ and $\gamma(\Avar) =_\alpha^{\nu,
    %     \chi,k+1} \gamma'(\Avar)$;
    %   \item we can write $\gamma(\Avar) = \abs{\avar_1 \dots \avar_m}{u}$ and
    %     $\gamma'(\Avar) = \abs{\bvar_1 \dots \bvar_m}{w}$
    %   \item there exist $t_1,\dots,t_m$ such that $\subrel{s_i,\gamma,t_i}$ for
    %     all $i$ and $\subrel{u,\delta,t}$ for $\delta = [\avar_1:=t_1,\dots,
    %     \avar_m:=t_m]$
    %   \item there exist $t_1',\dots,t_m'$ such that $\subrel{s_i',\gamma,t_i'}$ for
    %     all $i$ and $\subrel{w,\delta',t}$ for $\delta' = [\bvar_1:=t_1',\dots,
    %     \bvar_m:=t_m']$ \\
    %   \end{itemize}
    %   We conclude $t =_\alpha^{\nu,\chi,k+1} t'$ by the induction hypothesis on
    %   $\subrel{u,\delta,t}$ and $\subrel{w,\delta',t'}$.  To see that we are indeed
    %   allowed to apply the induction hypothesis, we observe:
    %   \begin{itemize}
    %   \item Denote $\mu' = \nu[\avar_1:=k+1,\dots,\avar_m:=k+m]$ (where, if
    %     $\avar_i = \avar_j$ for $i < j$ then $\mu'(\avar_i) = k+j$), and similarly
    %     $\xi' = \chi[\bvar_1:=k+1,\dots,\bvar_m:=k+m]$; then from $\gamma(\Avar)
    %     =_\alpha^{\nu,\chi,k+1} \gamma'(\Avar)$ we obtain:
    %     $u =_\alpha^{\mu',\xi',k+m+1} w$.
    %   \item For all $\cvar \in \FV(u)$ with $\mu'(\cvar) = 0$ we clearly do not have
    %     $\cvar = \avar_i$ for any $i$.  So necessarily $\cvar \in
    %     \FV(\gamma(\Avar))$ and $\nu(\cvar) = 0$ too; by Lemma
    %     \ref{lem:alphafreevar} therefore $\cvar \in \FV(\gamma'(\Avar))$ and
    %     $\chi(\cvar) = 0$. But if some $\bvar_i = \cvar$, then $\cvar \in
    %     \FV(\gamma'(\Avar))$ would not hold; hence, this is not the case, so
    %     $\delta(\cvar) = \delta'(\cvar) = \cvar$.  We indeed have $\cvar
    %     =_\alpha^{\nu,\chi,k+1} \cvar$.
    %   \item For all $\cvar \in \FV(u),\cvar' \in \FV(v)$ with $0 < \mu'(\cvar) =
    %     \xi'(\cvar') \leq k$ we clearly do not have $\cvar = \avar_i$ or $\cvar' =
    %     \bvar_i$ for any $i$.  So necessarily $\cvar \in \FV(\gamma(\Avar))$ and
    %     $\cvar' \in \FV(\gamma'(\Avar))$, and $\nu(\cvar) = \mu'(\cvar) =
    %     \xi'(\cvar') = \chi(\cvar) > 0$.  Hence, $\cvar\delta = \cvar =_\alpha^{
    %     \nu,\chi,k+1} \cvar' = \cvar'\delta'$ .
    %   \item For all $\cvar \in \FV(u),\cvar' \in \FV(v)$ with $k < \mu'(\cvar) =
    %     \xi'(\cvar') =: j$, we must have $\cvar = \avar_{j-k}$ and $\cvar' =
    %     \bvar_{j-k}$.  Moreover, by definition $\avar_l \neq \avar_{j-k}$ for any
    %     $l > j-k$; and $\bvar_l \neq \bvar_{j-k}$ for any $l > j-k$  Hence,
    %     $\delta(\cvar) = t_{j-k}$ and $\delta'(\cvar') = t'_{j-k}$.
    %     By the induction hypothesis for each $\subrel{s_i,\gamma,t_i}$ we have
    %     $\delta(\cvar) = t_{j-k} =_\alpha^{\nu,\chi,k+1} t'_{j-k}$.
    %   \item $\domain(\delta) \cap \M = \domain(\delta') \cap \M = \emptyset$
    %   \end{itemize}
    % \end{itemize}
\end{proof}

\begin{corollary}\label{cor:substitutionalpha}
If $s =_\alpha s'$ and $\subrel{s,\gamma,t}$ and $\subrel{s',\gamma',t'}$ and
  $\gamma(x) =_\alpha \gamma'(x)$ for all $x \in (\FV(s) \cup \FMV(s)) \cap
  \domain(\gamma)$ and $\domain(\gamma) = \domain(\gamma')$, then
  $t =_\alpha t'$.
\end{corollary}

\subsection{Some results on $\alpha$-equivalence and substitution}

We will now prove several useful results regarding substitution that will often
be silently used in proofs.

\begin{lemma}\label{lem:appsubstitute}
We have:
\begin{enumerate}
\item
  If $\subrel{s_i,\gamma,t_i}$ for $0 \leq i \leq n$, then $\subrel{s_0 \cdot
  s_1 \cdots s_n,\gamma,t_0 \cdot t_1 \cdots t_n}$.
\item
  If $\subrel{s_0 \cdot s_1 \cdots s_n,\gamma,t}$, then we can write $t = t_0 \cdot t_1 \cdots t_n$
  with $\subrel{s_i,\gamma,t_i}$ for $0 \leq i \leq n$.
\end{enumerate}
\end{lemma}

\begin{proof}
Both sides are immediate by definition.
    % 
    % In the following, let $s = s_0 \cdot s_1 \cdots s_n$, and write $s_0 = h(u_1,
    % \dots,u_k)$ with $k \geq 0$ (this is always possible), so $s = h(u_1,\dots,u_k,
    % s_1,\dots,s_n)$.
    % 
    % First suppose $\subrel{s_i,\gamma,t_i}$ for $0 \leq i \leq n$.
    % Then (by definition of $\subrel{}$) necessarily $t_0 = w \cdot v_1 \cdots v_k$,
    % where $\subrel{h,\gamma,w}$ and $\subrel{u_i,\gamma,v_i}$ for $1 \leq i \leq k$.
    % Hence, writing $t = t_0 \cdot t_1 \cdots t_n$ we have $t = (w \cdot v_1 \cdots
    % v_k) \cdot t_1 \cdots t_n$.  Since $\cdot$ is left-associative, this is exactly
    % $w \cdot v_1 \cdots v_k \cdot t_1 \cdots t_n$, and $\subrel{h(u_1,\dots,u_k,s_1,
    % \dots,s_n),\gamma,t}$ follows immediately.
    % 
    % Next suppose $\subrel{s,\gamma,t}$.  Then $t = w \cdot v_1 \cdots v_k \cdot t_1
    % \cdots t_n$ with $\subrel{h,\gamma,w}$ and $\subrel{u_i,\gamma,v_i}$ for $1
    % \leq i \leq k$ and $\subrel{s_i,\gamma,t_i}$ for $1 \leq i \leq n$.  Write $t_0
    % := w \cdot v_1 \cdots v_k$; then also $t = t_0 \cdot t_1 \cdots t_n$, and
    % $\subrel{s_0,\gamma,t_0}$ follows immediately.
\end{proof}

Hence, viewing substitution as a function rather than a relation, we have shown
that $(s_0 \cdot s_1 \cdots s_n)\gamma = (s_0\gamma) \cdot (s_1\gamma) \cdots
(s_n\gamma)$ as claimed in the text.

\begin{lemma}\label{lem:substitutionrefl}
For all terms $s$ and substitutions $\gamma$ such that (1) $\domain(\gamma) \cap
\FMV(s) = \emptyset$, and (2) $\gamma(x) = x$ for all $x \in \FV(s)$ we have:
$\subrel{s,\gamma,s}$.
\end{lemma}

\begin{proof}
By a straightforward induction on the size of $s$.  For the case $s =
\abs{x}{s'}$ we can choose $x$ as the ``fresh'' variable.
    % 
    % \begin{itemize}
    % \item If $s = \afun$ then clearly $\subrel{s,\gamma,s}$
    % \item If $s = \avar$ then by assumption $\gamma(\avar) = \avar$, so $\subrel{s,
    %   \gamma,s}$.
    % \item If $s = h(s_1,\dots,s_n)$ with $n > 0$ then by the induction hypothesis,
    %   $\subrel{h,\gamma,h}$ and $\subrel{s_i,\gamma,s_i}$ for all $i$; hence
    %   $\subrel{s,\gamma,h \cdot s_1 \cdots s_n}$, and $h \cdot s_1 \cdots s_n$ is
    %   exactly $s$.
    % \item If $s = \tuple{s_1}{s_n}$ then by the induction hypothesis
    %   $\subrel{s_i,\gamma,s_i}$ for all $i$, so $\subrel{s,\gamma,\tuple{s_1}{s_n}}$
    %   follows.
    % \item If $s = \meta{\Avar}{s_1,\dots,s_k}$, then by the induction hypothesis,
    %   $\subrel{s_i,\gamma,s_i}$ for $1 \leq i \leq k$.  Since $\Avar \notin
    %   \domain(\gamma)$, we indeed have $\subrel{s,\gamma,\meta{\Avar}{s_1,\dots,
    %   s_k}}$.
    % \item If $s = \abs{\avar}{s'}$ then note that $\gamma(\bvar) = \bvar$ for all
    %   $\bvar \in \FV(s)$, and that $\avar \notin \FV(s)$ and therefore $\avar \neq
    %   \bvar$ for any $\bvar \in \FV(s)$, so clearly
    %   $\avar \notin \FV(\gamma(\bvar))$ holds for all $\bvar \in \FV(s)$.
    %   Also note that $\gamma' := [\avar:=\avar] \cup [\bvar:=\gamma(\bvar) \mid
    %   \bvar \in \domain(\gamma) \setminus \{\avar\}]$ satisfies the property that
    %   $\gamma'(\bvar) = \bvar$ for any $\bvar \in \FV(s')$. Since
    %   $\FMV(s) = \FMV(s')$, we also have $\domain(\gamma') \cap \FMV(s') =
    %   \domain(\gamma) \cap \FMV(s) = \emptyset$.
    %   Hence, we can apply the induction hypothesis to obtain $\subrel{s',\gamma',
    %   s'}$, and therefore $\subrel{s,\gamma,\abs{\avar}{s'}}$.
    % \qedhere
    % \end{itemize}
\end{proof}

Hence, applying an irrelevant substitution can be done without effect; even
without any variables being renamed.

\begin{lemma}\label{lem:substextend}
Suppose $\gamma(x) = \delta(x)$ for all $x \in \FV(s)$, and $\domain(\gamma)
\cap \FMV(s) = \domain(\delta) \cap \FMV(s)$ and $\gamma(\Avar) = \delta(\Avar)$
for $\Avar \in \FMV(s) \cap \domain(\gamma)$.  Then $\subrel{s,\gamma,t}$
implies $\subrel{s,\delta,t}$.
\end{lemma}

\begin{proof}
We prove the lemma by a straightforward induction on the size of $s$.
For the abstraction case, we observe that the definition of ``fresh'' allows us
to choose the same variable for $\delta$ as for $\gamma$, since $\gamma(\bvar) =
\delta(\bvar)$ for all $\bvar \in \in \FV(s)$.
%    % 
%    % \begin{itemize}
%    % \item
%    %   If $s = \afun$ then $t = \afun$ and indeed $\subrel{s,\delta,t}$.
%    % \item
%    %   If $s = \avar$ then $t = \gamma(\avar) = \delta(\avar)$ by assumption (as
%    %   $\avar \in \FV(s)$).
%    % \item 
%    %   If $s = h(s_1,\dots,s_n)$ with $n > 0$ then $t = w \cdot t_1 \cdots t_n$ with
%    %   $\subrel{h,\gamma,w}$ and $\subrel{s_i,\gamma,t_i}$ for all $i$.
%    %   By the induction hypothesis, also $\subrel{h,\delta,w}$ and $\subrel{s_i,
%    %   \delta,t_i}$ for all $i$, so indeed $\subrel{s,\delta,t}$.
%    % \item
%    %   If $s = \tuple{s_1}{s_n}$ then $t = \tuple{t_1}{t_n}$ with $\subrel{s_i,
%    %   \gamma,t_i}$ for all $i$; the induction hypothesis gives $\subrel{s_i,\delta,
%    %   t_i}$ as well, so indeed $\subrel{s,\delta,t}$.
%    % \item
%    %   If $s = \abs{\avar}{s'}$ then $t = \abs{\cvar}{t'}$ where
%    %   (a) $\cvar$ has the same type as $\avar$,
%    %   (b) $\cvar \notin \FV(\gamma(\bvar))$ for any $\bvar \in \FV(s)$, and
%    %   therefore also $\cvar \notin \FV(\delta(\bvar))$ for any $\bvar \in \FV(s)$,
%    %   and
%    %   (c) $\subrel{s',[\avar:=\cvar] \cup [\bvar:=\gamma(\bvar) \mid \bvar \in
%    %   \domain(\gamma) \setminus \{\avar\}],t'}$, which means that also $\subrel{s',
%    %   [\avar:=\cvar] \cup [\bvar:=\delta(\bvar) \mid \bvar \in \domain(\delta)
%    %   \setminus \{\avar\}],t'}$ by the induction hypothesis.
%    % \item
%    %   If $s = \meta{\Avar}{s_1,\dots,s_k}$ with $\Avar \notin \domain(\gamma)$, then
%    %   by definition $t = \meta{\Avar}{t_1,\dots,t_k}$ with $\subrel{s_i,\gamma,t_i}$
%    %   for all $i$, so by the induction hypothesis $\subrel{s_i,\delta,t_i}$ as well.
%    %   Since $\Avar \notin \domain(\gamma) \cap \FMV(s)$, by assumption also
%    %   $\Avar \notin \domain(\delta) \cap \FMV(s)$, so since $\Avar \in \FMV(s)$ we
%    %   have $\Avar \notin \domain(\delta)$; hence, we conclude
%    %   $\subrel{s,\delta,t}$ as well.
%    % \item
%    %   If $s = \meta{\Avar}{s_1,\dots,s_k}$ and $\Avar \in \domain(\gamma)$ then
%    %   there exist $t_1,\dots,t_k$ with $\subrel{s_i,\gamma,t_i}$ and
%    %   $\gamma(\Avar) = \abs{\avar_1 \dots \avar_k}{t} = \delta(\Avar)$.
%    %   By the induction hypothesis also $\subrel{s_i,\delta,t_i}$, and therefore
%    %   $\subrel{s,\delta,t}$ follows immediately.
%    %   \qedhere
%    % \end{itemize}
\end{proof}

Hence, the only relevant part of a substitution is its value on the
meta-variables and unbound variables of the term it is applied on.

Our following result is a helper to assess what substitution does to a longer
abstraction.

\begin{lemma}\label{lem:abssubst}
If $\subrel{\abs{\avar_1 \dots \avar_n}{s},\gamma,u}$ then $u = \abs{\bvar_1
\dots \bvar_n}{t}$ such that:
\begin{itemize}
\item each $\bvar_i \notin \FV(\gamma(\cvar))$ for any $\cvar \in (\FV(s) \cup
  \FMV(s)) \setminus \{\avar_1,\dots,\avar_n\}$
\item if $\bvar_i = \bvar_j$ for some $i < j$, then $\avar_i \notin \FV(s)$ or
  $\avar_i = \avar_k$ for some $k > i$ 
\item $\subrel{s,\gamma',t}$ where $\gamma'$ is any substitution with
  $\domain(\gamma') \cap \M = \domain(\gamma) \cap \M$ and
  $\gamma'(\Avar) = \gamma(\Avar)$ for $\Avar \in \FMV(s) \cap \domain(\gamma)$,
  and $\gamma'(\avar_i) = \bvar_i$ if there is no $j > i$ with $\avar_i =
  \avar_j$, and $\gamma'(\avar) = \gamma(\avar)$ for $\avar \in \V \setminus
  \{\avar_1, \dots,\avar_n\}$.
\end{itemize}
\end{lemma}

\begin{proof}
By induction on $n$.  For $n = 0$ the lemma clearly holds (using Lemma
\ref{lem:substextend}).
Now if $\subrel{\abs{\avar_1 \cdots \avar_n}{s},\gamma,u}$ and $n > 0$ then
by definition $u = \abs{\bvar_1}{u'}$ with $\bvar_1 \notin \FV(\gamma(\cvar))$
for any $\cvar \in \FV(\abs{\avar_1 \dots \avar_n}{s}) \cup \FMV(\abs{\avar_1
\dots \avar_n}{s}) = (\FV(s) \setminus \{\avar_1,\dots,\avar_n\}) \cup \FMV(s)$,
and $\subrel{\abs{\avar_2 \dots \avar_n}{s}, [\avar_1:=\bvar_1] \cup [\cvar:=
\gamma(\cvar) \mid \cvar \in \domain(\gamma) \setminus \{\avar_1\}],u'}$.
Each of the three requirements now follows easily by the induction hypothesis and the properties above.
%    % 
%    % Write $\gamma^{\avar_1:=\bvar_1} = [\avar_1:=\bvar_1] \cup [\cvar:=\gamma(\cvar)
%    % \mid \cvar \in \domain(\gamma) \setminus \{\avar_1\}]$.  We have:
%    % \begin{itemize}
%    % \item By the first part of the induction hypothesis:
%    %   for $i > 1$ each $\bvar_i \notin \FV(\gamma^{\avar_1:=\bvar_1}(\cvar))$ for any
%    %   $\cvar \in \FV(s) \setminus \{\avar_2,\dots,\avar_n\}$.  Since
%    %   $\gamma^{\avar_1:=\bvar_1}(\cvar) = \gamma(\cvar)$ for any $\cvar \neq
%    %   \avar_1$, this implies $\bvar_i \notin \FV(\gamma(\cvar))$ for any $\cvar \in
%    %   \FV(s) \setminus \{\avar_1,\dots,\avar_n\}$.
%    % \item Using the case $\cvar = \avar_1$, this also implies that, if $\avar_1 \in
%    %   \FV(s) \setminus \{\avar_2,\dots,\avar_n\}$, then $y_i \neq y_1$.
%    %   Hence, if $y_1 = y_i$ for $1 < i$ then $x_1 \notin \FV(s)$ or $x_1 = x_k$ for
%    %   some $k > 1$.
%    % \item By the second part of the induction hypothesis: if $\bvar_i = \bvar_j$ for
%    %   $1 < i < j$ then $\avar_i \notin \FV(s)$ or $\avar_i = \avar_k$ for some $k >
%    %   i$.  Hence, combined with the previous point, this holds for \emph{all}
%    %   $i < j$; which gives the second requirement we have to prove.
%    % \item Let $\gamma'$ be any substitution with $\domain(\gamma') \cap \M =
%    %   \domain(\gamma) \cap \M$ and $\gamma'(\Avar) = \gamma(\Avar)$ for $\Avar \in
%    %   \FMV(s) \cap \domain(\gamma)$ and $\gamma'(\avar_i) = \bvar_i$ if there is no
%    %   $j > i$ with $\avar_i = \avar_j$, and $\gamma'(\cvar) = \gamma(\cvar)$ for
%    %   $\cvar \in \V \setminus \{\avar_1,\dots,\avar_n\}$.  Then:
%    %   \begin{itemize}
%    %   \item $\domain(\gamma') \cap \M = \domain(\gamma^{\avar_1:=\bvar_1}) \cap \M
%    %     = \domain(\gamma) \cap \M$
%    %   \item $\gamma'(\Avar) = \gamma^{\avar_1:=\bvar_1} = \gamma(\Avar)$ for all
%    %     $\Avar \in \FMV(s) \cap \domain(\gamma)$
%    %   \item clearly, for $1 < i \leq n$: $\gamma'(\avar_i) = \bvar_i$ if there is no
%    %     $j > i$ with $\avar_i = \avar_j$
%    %   \item for $\cvar \in \V \setminus \{\avar_2,\dots,\avar_n\}$ we have
%    %     $\gamma'(\cvar) = \gamma^{\avar_1:=\bvar_1}(\cvar)$:
%    %     \begin{itemize}
%    %     \item if $\cvar = \avar_1$ then since $\cvar \notin \{\avar_2,\dots,
%    %       \avar_n\}$ we have by assumption that $\gamma'(\avar_1) = \bvar_1 =
%    %       \gamma^{\avar_1:=\bvar_1}(\avar_1)$
%    %     \item if $\cvar \neq \avar_1$ then by assumption $\gamma'(\cvar) =
%    %       \gamma(\cvar) = \gamma^{\avar_1:=\bvar_1}(\cvar)$ by definition
%    %     \end{itemize}
%    %   \end{itemize}
%    %   \ \\
%    %   Hence, by the induction hypothesis we obtain $\subrel{s,\gamma',t}$.
%    %   \qedhere
%    % \end{itemize}
\end{proof}

We also provide a helper result combining substitutions and free variables.

\begin{lemma}\label{lem:varinsubstitute}
Let $s,t$ be terms and $\gamma$ a substitution with $\domain(\gamma) \subseteq
\V$, such that $\subrel{s,\gamma,t}$.
Suppose $\avar \in \FV(\gamma(\bvar))$ for some $\bvar \in \FV(s)$.
Then $\avar \in \FV(t)$.
\end{lemma}

\begin{proof}
By a straightforward induction on the definition of $\subrel{s,\gamma,t}$.
    % \begin{itemize}
    % \item If $s = \afun$ then there is no $\bvar \in \FV(s)$, so there is nothing to
    %   prove.
    % \item If $s = \bvar$ then $t = \gamma(\bvar)$ and by assumption $\avar \in
    %   \FV(\gamma(\bvar)) = \FV(t)$.
    % \item If $s = h(s_1,\dots,s_n)$ then $t = w \cdot t_1 \cdots t_n$ with
    %   $\subrel{h,\gamma,w}$ and $\subrel{s_i,\gamma,t_i}$ for all $i$.
    %   By definition, $\FV(s) = \FV(h) \cup \FV(s_1) \cup \dots \cup \FV(s_n)$, so
    %   $\avar \in \FV(\gamma(\bvar))$ for some $\bvar$ that occurs either in $\FV(h)$
    %   or in some $\FV(s_i)$.  By the induction hypothesis then, $\avar \in \FV(w)$
    %   or $\avar \in \FV(t_i)$ respectively.  By definition of $\cdot$ and $\FV$ we
    %   easily obtain $\avar \in \FV(t)$.
    % \item If $s = \tuple{s_1}{s_n}$ then $t = \tuple{t_1}{t_n}$ and by the
    %   induction hypothesis, $\avar \in \FV(t_i)$ for some $i$; hence $\avar \in
    %   \FV(t)$.
    % \item If $s = \meta{\Avar}{s_1,\dots,s_k}$ then since $\Avar \notin \domain(
    %   \gamma)$ we have $t = \meta{\Avar}{t_1,\dots,t_k}$ and by the induction
    %   hypothesis there is some $i$ such that $\avar \in \FV(t_i)$; hence $\avar \in
    %   \FV(t)$.
    % \item If $s = \abs{\cvar}{s'}$ then $t = \abs{\cvar'}{t'}$ with
    %   $\cvar' \notin \FV(\gamma(w))$ for any $w \in \FV(s)$ (**), and
    %   $\subrel{s',\gamma^{\cvar:=\cvar'},t'}$.
    %   Now suppose $\bvar \in \FV(s) = \FV(s') \setminus \{\cvar\}$, and $\avar \in
    %   \FV(\gamma(\bvar))$.
    %   Since $\bvar \neq \cvar$ we have $\gamma^{\cvar:=\cvar'}(\bvar) = \gamma(
    %   \bvar)$, so by the induction hypothesis, $\avar \in \FV(t')$.  Moreover,
    %   $\avar \neq \cvar'$ since $\cvar' \notin \FV(\gamma(\bvar))$ by (**).
    %   Hence, $\avar \in \FV(t') \setminus \{\cvar'\} = \FV(t)$.
    % \end{itemize}
\end{proof}

\subsection{Combining substitutions}

The proof that $(s\gamma)\delta = s(\gamma\delta)$ is actually quite complex,
due to the interplay of substitution and variable renaming.  For this reason,
we split it up into multiple smaller steps.

To start, let us define the combination of two substitutions as a relation:

\begin{definition}
For substitutions $\gamma,\delta,\eta$ we say that $\subrel{\gamma,\delta,\eta}$
if:
\begin{itemize}
\item $\domain(\eta) = \domain(\gamma) \cup \domain(\delta)$, and
\item $\subrel{\gamma(\avar),\delta,\eta(\avar)}$ for all $\avar \in
  \domain(\gamma)$
\item $\delta(\avar) = \eta(\avar)$ for all $\avar \in \domain(\delta) \setminus
  \domain(\gamma)$
\end{itemize}
\end{definition}

We first prove a version of our desired result where $\gamma$ has a limited
domain.

\begin{lemma}\label{lem:combinesubst:allbound}
Let $\domain(\gamma) \subseteq \V$, let $s,t$ be terms and let
$\delta,\eta$ be substitutions, with:
\begin{itemize}
\item $\domain(\delta) \setminus \V = \domain(\eta) \setminus \V$
\item $\delta(\Avar) = \eta(\Avar)$ for all $\Avar \in \domain(\delta) \setminus
  \V$
\item $\subrel{\gamma(\avar),\delta,\eta(\avar)}$ for all $\avar \in \FV(s)$
\item $\subrel{s,\gamma,t}$
\end{itemize}
Then there exists $u$ such that both $\subrel{t,\delta,u}$ and
$\subrel{s,\eta,u}$.
\end{lemma}

Note that the first three requirements above are satisfied if $\domain(\gamma)
\subseteq \V$ and $\subrel{\gamma,\delta,\eta}$ and $\subrel{s,\gamma,t}$.  We
phrase it more generally for the sake of a stronger induction hypothesis.

\begin{proof}
By induction on the size of $s$.

In the case of an abstraction $s = \abs{\avar}{s'}$ and $t = \abs{\bvar}{t'}$,
we choose the fresh variable $\cvar$ outside both $\FV(\delta(w))$ for all $w
\in \FV(t) \cup (\FMV(t) \cap \domain(\delta))$, and $\FV(\eta(w))$ for all
$w \in \FV(s) \cup (\FMV(s) \cap \domain(\eta))$.
Since $\delta$ extended with $[\bvar:=\cvar]$ and $\eta$ extended with
$[\avar:=\cvar]$ are both substitutions with domain $\subseteq \Vbound$,
we can apply the induction hypothesis.  The case of a meta-application
$\meta{\Avar}{s_1,\dots,s_k}$ is trivial with the induction hypothesis if
$\Avar \notin \domain(\delta)$, and quite easy using
Lemma~\ref{lem:substdefined} if $\Avar \in \domain(\delta)$.
    % 
    % \begin{itemize}
    % \item If $s = \afun$ or $s = \avar \in \Vfree$ then $t = \afun$;
    %   we choose $u := \afun$ as well.
    % \item If $s = \avar \in \V$ then $t = \gamma(\avar)$, and we let
    %   $u := \eta(\avar)$.  Then by choice of $\eta$, we indeed have
    %   $\subrel{t,\delta,u}$ and clearly we also have $\subrel{s,\eta,u}$.
    % \item If $s = h(s_1,\dots,s_n)$ with $n > 0$, then by definition
    %   $t = q \cdot t_1 \cdots t_n$ where $\subrel{h,\gamma,q}$ and
    %   $\subrel{s_i,\gamma,t_i}$ for all $i$.  By the induction hypothesis, there
    %   exist $w$ such that both $\subrel{q,\delta,w}$ and $\subrel{h,\eta,w}$, and
    %   $u_1,\dots,u_n$ such that for all $i$ both $\subrel{t_i,\delta,u_i}$ and
    %   $\subrel{s_i,\eta,u_i}$.  Choose $u := w \cdot u_1 \cdots u_n$.
    %   Then $\subrel{t,\delta,u}$ by Lemma \ref{lem:appsubstitute}, and
    %   $\subrel{s,\eta,u}$ by definition.
    % \item If $s = \tuple{s_1}{s_n}$ then by definition $t = \tuple{t_1}{t_n}$ with
    %   $\subrel{s_i,\gamma,t_i}$ for all $i$, and by the induction hypothesis we
    %   find $u_1,\dots,u_n$ such that both $\subrel{t_i,\delta,u_i}$ and
    %   $\subrel{s_i,\eta,u_i}$ for all $i$.  Choose $u := \tuple{u_1}{u_n}$.
    % \item If $s = \abs{\avar}{s'}$ then $t = \abs{\bvar}{t'}$ with
    %   $\bvar \notin \FV(\gamma(w))$ for any $w \in \FV(s)$, and we have
    %   $\subrel{s',\gamma^{\avar:=\bvar},t'}$ where $\gamma^{\avar:=\bvar} =
    %   [\avar:=\bvar] \cup [w:=\gamma(w) \mid w \in \domain(\gamma) \setminus
    %   \{\avar\}]$.  Note that the domain of $\gamma^{\avar:=\bvar}$ is also
    %   limited to variables.
    %   Let $\cvar$ be a variable of the same type as $\avar$, such that:
    %   \begin{itemize}
    %   \item $\cvar \notin \FV(\delta(w))$ for any $w \in \FV(t) \cup
    %     (\FMV(t) \cap \domain(\delta))$;
    %   \item $\cvar \notin \FV(\eta(w))$ for any $w \in \FV(s) \cup
    %     (\FMV(s) \cap \domain(\eta))$.
    %   \end{itemize}
    %   \ \\
    %   Since $\cvar$ is only required to be unequal to a finite number of variables,
    %   and $\Vbound$ has infinitely many elements of each type, such a variable can
    %   always be found.
    % 
    %   Now let $\delta^{\bvar:=\cvar} = [\bvar:=\cvar] \cup [w:=\delta(w) \mid w \in
    %   \domain(\delta)\setminus \{\bvar\}]$ and let $\eta^{\avar:=\cvar} = [\avar:=
    %   \cvar] \cup [w:=\eta(w) \mid w \in \domain(\eta) \setminus \{\avar\}]$.  Then
    %   the domains and values for the meta-variables are the same as in $\delta$ and
    %   $\eta$ respectively, and we have $\subrel{\gamma^{\avar:=\bvar}(w),
    %   \delta^{\bvar:=\cvar},\eta^{\avar:=\cvar}(w)}$ for all $w \in \FV(s')$:
    %   \begin{itemize}
    %   \item for $w = \avar$ we have $\subrel{\bvar,\delta^{\bvar:=\cvar},\cvar}$;
    %   \item and for all other $w$ we have $\subrel{\gamma(w),\delta^{\bvar:=\cvar},
    %     \eta(w)}$ by Lemma \ref{lem:substextend}, because $\bvar \notin
    %     \FV(\gamma(w))$ when $w \in \FV(s) = \FV(s') \setminus \{\avar\}$ (by
    %     choice of $\bvar$).
    %   \end{itemize}
    %   \ \\
    %   Hence, we can apply the induction hypothesis on $\subrel{s',\gamma^{\avar:=
    %   \bvar},t'}$ to obtain $u'$ such that both $\subrel{t',\delta^{\bvar;=\cvar},
    %   u'}$ and $\subrel{s',\eta^{\avar:=\cvar}, u'}$.  We choose $u :=
    %   \abs{\cvar}{u'}$.  Due to the requirements on $\cvar'$ we have both
    %   $\subrel{t,\delta,u}$ and $\subrel{s,\eta,u}$.
    % \item If $s = \meta{\Avar}{s_1,\dots,s_k}$ with $\avar \in \M$ and $\Avar \notin
    %   \domain(\delta)$, note that $\Avar \notin \domain(\eta)$ as well, and
    %   $\Avar \notin \domain(\gamma)$ by assumption.  Hence,
    %   $t = \meta{\Avar}{t_1,\dots,t_k}$ for some $t_1,\dots,t_k$ such that
    %   $\subrel{s_i,\gamma,t_i}$ for all $i$.  By the induction hypothesis on each
    %   $s_i$, there exist $u_1,\dots,u_k$ such that $\subrel{t_i,\delta,u_i}$ and
    %   $\subrel{s_i,\eta,u_i}$ for all $i \in \{1,\dots,k\}$.  We are done choosing
    %   $u := \meta{\Avar}{u_1,\dots,u_k}$.
    % \item Finally, if $s = \meta{\Avar}{s_1,\dots,s_k}$ with $\Avar \in \M$ and
    %   $\Avar \in \domain(\delta)$, then note that $\Avar \notin \domain(\gamma)$ and
    %   $\eta(\Avar) = \gamma(\Avar)$.  But then $t = \meta{\Avar}{t_1,\dots,t_k}$
    %   with $\subrel{s_i,\gamma,t_i}$ for all $i$, and by the induction hypothesis we
    %   can find $u_1,\dots,u_k$ such that both $\subrel{t_i,\delta,u_i}$ and
    %   $\subrel{s_i,\eta,u_i}$ for all $i$.
    %   Write $\delta(\Avar) = \eta(\Avar) = \abs{z_1 \dots z_k}{q}$, and let
    %   $\chi := [z_1:=u_1,\dots,z_k:=u_k]$.  Then by
    %   Lemma~\ref{lem:substdefined} there exists $u$ such that
    %   $\subrel{q,\chi,u}$.  Then by definition both $\subrel{t,\delta,u}$ and
    %   $\subrel{s,\eta,u}$.
    %   \qedhere
    % \end{itemize}
\end{proof}

Lemma~\ref{lem:combinesubst:allbound} gives us an ``exists'' result.  If we
additionally limit the domain of $\delta$ (and consequently $\eta$), we can also
find a ``forall'' result:

\begin{lemma}\label{lem:combinesubst:gammadeltalimited}
Let $s,t,u$ be terms and let $\gamma,\delta,\eta$ be substitutions, with:
\begin{itemize}
\item $\domain(\gamma) \cup \domain(\delta) \cup \domain(\eta) \subseteq \V$
\item $\subrel{\gamma(\avar),\delta,\eta(\avar)}$ for all $\avar \in \FV(s)$
\item $\subrel{s,\gamma,t}$
\item $\subrel{s,\eta,u}$
\end{itemize}
Then $\subrel{t,\delta,u}$ as well.
\end{lemma}

\begin{proof}
By induction on the size of $s$.  The only difficult case is abstraction:
$s = \abs{\avar}{s'}$, $t = \abs{\bvar}{t'}$ and $u = \abs{\cvar}{u'}$.  The
challenging part is to show that $\cvar \notin \FV(\delta(w))$ for any $w \in
\FV(t)$.  We do this by finding a term $u'$ that is $\alpha$-equal to $u$ by
Lemma~\ref{lem:combinesubst:allbound}, and use Lemma~\ref{lem:varinsubstitute}
to show that if $\cvar \in \FV(\delta(w))$ then also $\cvar \in \FV(u)$, which
gives the required contradiction.
    % 
    % \begin{itemize}
    % \item If $s = \afun$ then $t = u = \afun$ as well, and indeed
    %   $\subrel{t,\delta,u}$.
    % \item If $s = \avar$ then $t = \gamma(\avar)$ and $u = \eta(\avar)$.
    %   By assumption, $\subrel{\gamma(\avar),\delta,\eta(\avar)}$.
    % \item If $s = h(s_1,\dots,s_n)$ then $t = w \cdot t_1 \cdots t_n$ and $u =
    %   q \cdot u_1 \cdots u_n$ with $\subrel{h,\gamma,w}$ and $\subrel{h,\eta,u}$,
    %   and both $\subrel{s_i,\gamma,t_i}$ and $\subrel{s_i,\gamma,u_i}$ as well.
    %   By the induction hypothesis, $\subrel{w,\delta,q}$ and $\subrel{t_i,\delta,
    %   u_i}$ for all $i$, so indeed $\subrel{t,\delta,u}$ by
    %   Lemma~\ref{lem:appsubstitute}.
    % \item If $s = \tuple{s_1}{s_n}$ then we similarly complete immediately by the
    %   induction hypothesis.
    % \item If $s = \meta{\Avar}{s_1,\dots,s_k}$ then we similarly complete by the
    %   induction hypothesis, since $\Avar$ is not in the domain of any of the
    %   substitutions.
    % \item If $s = \abs{\avar}{s'}$ then $t = \abs{\bvar}{t'}$ with
    %   $\bvar \notin \FV(\gamma(w))$ for any $w \in \FV(s)$, and we have
    %   $\subrel{s',\gamma^{\avar:=\bvar},t'}$ where
    %   $\gamma^{\avar:=\bvar} = [\avar:=\bvar] \cup [w:=\gamma(w) \mid w \in
    %   \domain(\gamma) \setminus \{\avar\}]$.  Note that the domain of
    %   $\gamma^{\avar:=\bvar}$ is also limited to variables.
    %   Moreover, $u = \abs{\cvar}{u'}$ with $\cvar \notin \FV(\eta(w))$ for any
    %   $w \in \FV(s)$, and we have $\subrel{s',\eta^{\avar:=\cvar},t'}$.
    % 
    %   Now suppose $\cvar \in \FV(\delta(w))$ for some $w \in \FV(t)$.  Let $u'$
    %   be such that both $\subrel{t',\delta,u'}$ and $\subrel{s',\eta,u'}$; such
    %   $u'$ exists by Lemma~\ref{lem:combinesubst:allbound}.
    %   By Lemma~\ref{lem:varinsubstitute}, $\cvar \in \FV(u')$.  So by
    %   Corollaries~\ref{corr:alphafreevar} and~\ref{cor:substitutionalpha},
    %   also $\cvar \in \FV(u)$, which is clearly not the case.
    %   We conclude that $\cvar \notin \FV(\delta(w))$ for any $w \in \FV(t)$.
    % 
    %   We also observe that $\domain(\gamma^{\avar:=\bvar}) \cup
    %   \domain(\delta^{\bvar:=\cvar}) \cup \domain(\eta^{\avar:=\cvar}) \subseteq
    %   \domain(\gamma) \cup \domain(\delta) \cup \domain(\eta) \cup \{\avar,\bvar\}
    %   \subseteq \V$.  Moreover, for $w \in \FV(s')$ we have
    %   $\subrel{\gamma^{\avar:=\bvar}(w),\delta^{\bvar:=\cvar},
    %   \eta^{\avar:=\cvar}(w)}$:
    %   \begin{itemize}
    %   \item If $w = \avar$ then indeed $\subrel{\bvar,\delta^{\bvar:=\cvar},\cvar}$.
    %   \item Otherwise, $w \in \FV(s)$ and $\gamma^{\avar:=\bvar}(w) = \gamma(w)$
    %     and $\eta^{\avar:=\cvar}(w) = \eta(w)$.  Since $\bvar \notin \FV(\gamma(w))$
    %     by assumption, we obtain from $\subrel{\gamma(w),\delta,\eta(w)}$ that also
    %     $\subrel{\gamma(w),\delta^{\bvar:=\cvar},\eta(w)}$, which is exactly what we
    %     need. \\
    %   \end{itemize}
    %   Hence, we can apply the induction hypothesis to deduce $\subrel{t',\delta^{
    %   \bvar:=\cvar},u'}$.  This then gives us $\subrel{t,\delta,u}$.
    %   \qedhere
    % \end{itemize}
\end{proof}

We use this to obtain another ``forall'' result, where meta-variables \emph{are}
allowed in the domain, but we expect substitutions of a specific form.

\begin{lemma}\label{lem:combinesubst:special}
Let $s,t,u,q_1,\dots,q_n$ be terms, $\avar_1,\dots,\avar_n,\bvar_1,\dots,\bvar_n
\in \Vbound$ and $\delta$ a substitution with $\{\avar_1,\dots,\avar_n\} \cap
\domain(\delta) = \emptyset$.  Suppose that
$\subrel{s,[\avar_1:=\bvar_1,\dots,\avar_n:=\bvar_n] \cup \delta,t}$ and
$\subrel{s,[\avar_1:=q_1,\dots,\avar_n:=q_n] \cup \delta,u}$. Suppose, moreover,
that:
\begin{itemize}
\item each $\bvar_i \notin \FV(\delta(\cvar))$ for any $\cvar \in (\FV(s)
  \setminus \{\avar_1,\dots,\avar_n\}) \cup (\FMV(s) \cap \domain(\delta))$
\item if $\bvar_i = \bvar_j$ for some $i < j$ then $\avar_i \notin \FV(s)$
  or $\avar_i = \avar_p$ for some $p > i$ as well.
\end{itemize}
Then we have $\subrel{t,[\bvar_1:=q_1,\dots,\bvar_n:=q_n],u}$ as well.
\end{lemma}

\begin{proof}
By induction on the size of $s$.
In the case of an abstraction, some careful checking of the restrictions on the
binder variables shows that we can apply the induction hypothesis.  In the case
of a meta-application, we use Lemma~\ref{lem:combinesubst:gammadeltalimited}.
    % 
    % \begin{itemize}
    % \item If $s = \afun$ then $t = u = \afun$ as well, and indeed
    %   $\subrel{t,[\vec{\bvar}:=\vec{q}],u}$ holds.
    % \item If $s = \avar_i$ with $i$ maximal, then $t = \bvar_i$, and $u = q_i$.
    %   Note that there is no $j > i$ such that $\bvar_i = \bvar_j$, since $i$ was
    %   maximal and $\avar_i \in \FV(s)$.  Hence, $\subrel{\bvar,[\vec{\bvar}:=
    %   \vec{q}],q_i}$ as well.
    % \item If $s = \cvar \in \V \setminus \{\avar_1,\dots,\avar_n\}$, then $t = u =
    %   \delta(\cvar)$.  Note that $\bvar_i \notin \FV(t)$ for any $i$ by the first
    %   requirement.  Hence, by Lemma~\ref{lem:substitutionrefl}, we have
    %   $\subrel{t,[\vec{\bvar}:=\vec{q}],u}$.
    % \item If $s = h(s_1,\dots,s_n)$ with $n > 0$ then $t = w \cdot t_1 \cdots t_n$
    %   with $\subrel{h,[\vec{\avar}:=\vec{\bvar}] \cup \delta,w}$ and
    %   $\subrel{s_i,[\vec{\avar}:=\vec{\bvar}] \cup \delta,t_i}$ for all $i$.
    %   Moreover, $u = v \cdot u_1 \cdots u_n$ with
    %   $\subrel{h,[\vec{\avar}:=\vec{q}] \cup \delta,v}$ and
    %   $\subrel{s_i,[\vec{\avar}:=\vec{q}] \cup \delta,u_i}$ for all $i$.
    %   By the induction hypothesis, $\subrel{w,[\vec{\bvar}:=\vec{q}] \cup \delta,v}$
    %   and $\subrel{t_i,\vec{\bvar}:=\vec{q}] \cup \delta,u_i}$ for all $i$, so
    %   $\subrel{t,[\vec{\bvar}:=\vec{q}] \cup \delta,u}$ follows by
    %   Lemma~\ref{lem:appsubstitute}.
    % \item If $s = \tuple{s_1}{s_n}$ then $t = \tuple{t_1}{t_n}$ and $u = \tuple{
    %   u_1}{u_n}$.  We immediately complete with the induction hypothesis.
    % \item If $s = \abs{\avar_{n+1}}{s'}$ then $t = \abs{\bvar_{n+1}}{t'}$ and
    %   $\subrel{s',[\avar_1:=\bvar_1,\dots,\avar_{n+1}:=\bvar_{n+1}] \cup
    %   \delta_{\setminus\{\avar_{n+1}\}},t'}$, where
    %   $\delta_{\setminus\{\avar_{n+1}\}} =
    %   [\delta(\cvar) \mid \cvar \in \domain(\delta) \setminus \{\avar_{n+1}\}]$.
    %   Note that:
    %   \begin{itemize}
    %   \item Let $\cvar \in (\FV(s') \setminus \{\avar_1,\dots,\avar_n,\avar_{n+1}\})
    %     \cup (\FMV(s') \cap \domain(\delta_{\setminus\{\avar_{n+1}\}}))$.
    % 
    %     This exactly means that $\cvar \in (\FV(s) \setminus \{\avar_1,\dots,
    %     \avar_n\}) \cup (\FMV(s) \cap \domain(\delta))$, so $\bvar_1,\dots,\bvar_n
    %     \notin \FV(\delta(\cvar))$.
    %     Moreover, $\bvar_{n+1} \notin \FV(\delta(\cvar))$ either, by definition of
    %     the substitution relation on abstractions.
    % 
    %     Thus, $\bvar_i \notin \FV(\delta(\cvar))$ for $1 \leq i \leq n+1$.
    %     Since $\cvar \neq \avar_{n+1}$, we also have $\bvar_i \notin
    %     \FV(\delta_{\setminus\{\avar_{n+1}\}}(\cvar))$.
    %   \item If $\bvar_i = \bvar_j$ for $i < j \leq n$ then $\avar_i \notin \FV(s)$
    %     or $\avar_i = \avar_p$ for some $p > i$; in the former case, either
    %     $\avar_i \notin \FV(s')$ either, or $\avar_i = \avar_{n+1}$ (and $n+1 > i$).
    %     If $\bvar_i = \bvar_{n+1}$ with $i$ maximal ($\leq n$), then by choice of
    %     $\bvar_{n+1}$ this variable does not occur in $\FV( ([\avar_1:=\bvar_1,
    %     \dots,\avar_n:=\bvar_n] \cup \delta)(\cvar) )$ for any variable or
    %     meta-variable $\cvar$ in $s$.  But (choosing $\cvar := \avar_i$), that
    %     means that either $\avar_i \notin \FV(s)$, or $\avar_i = \avar_p$ for some
    %     $n \geq p > i$.  Hence, $\avar_i \notin \FV(s')$ or $\avar_i = \avar_p$ for
    %     some $n+1 \geq p > i$. \\
    %   \end{itemize}
    %   We also have $u = \abs{\cvar_{n+1}}{u'}$ and $\subrel{s',[\avar_1:=q_1,\dots,
    %   \avar_n:=q_n,\avar_{n+1}:=\cvar_{n+1}] \cup \delta_{\setminus\{\avar_{n+1}\}},
    %   u'}$.  Hence, by the induction hypothesis,
    %   $\subrel{t',[\bvar_1:=q_1,\dots,\bvar_n:=q_n,\bvar_{n+1}:=\cvar_{n+1}] \cup
    %   \delta_{\setminus\{\avar_{n+1}\}},u'}$.  This is exactly what we need to
    %   obtain $\subrel{t,[\bvar_1:=q_1,\dots,\bvar_n:=q_n] \cup \delta,u}$.
    % \item If $s = \meta{\Avar}{s_1,\dots,s_k}$ with $\Avar \notin \domain(\delta)$,
    %   then $t = \meta{\Avar}{t_1,\dots,t_k}$ with $\subrel{s_i,[\vec{\avar}:=\vec{
    %   \bvar}] \cup \delta,t_i}$ for all $i$, and $u = \meta{\Avar}{u_1,\dots,u_k}$
    %   with $\subrel{s_i,[\vec{\avar}:=\vec{q}] \cup \delta,u_i}$ for all $i$.  By
    %   the induction hypothesis, $\subrel{t_i,[\vec{\bvar}:=\vec{q}],u_i}$ for all
    %   $i$, so we immediately obtain $\subrel{t,[\vec{\bvar}:=\vec{q}],u}$.
    % \item Finally, if $s = \meta{\Avar}{s_1,\dots,s_k}$ with $\Avar \in
    %   \domain(\delta)$, then write $\delta(\Avar) = \abs{\cvar_1 \dots \cvar_k}{w}$.
    %   Then there exist $t_1,\dots,t_k$ and $u_1,\dots,u_k$ with
    %   $\subrel{s_i,[\vec{\avar}:=\vec{\bvar}] \cup \delta,t_i}$ and
    %   $\subrel{s_i,[\vec{\avar}:=\vec{q}] \cup \delta,u_i}$ for all $i$, such that
    %   $\subrel{w,[\cvar_1:=t_1,\dots,\cvar_k:=t_k],t}$ and
    %   $\subrel{w,[\cvar_1:=u_1,\dots,\cvar_k:=u_k],u}$.
    %   By the induction hypothesis, each $\subrel{t_i,[\vec{\bvar}:=\vec{q}],u_i}$.
    % 
    %   Now write
    %   $\gamma' = [\cvar_1:=t_1,\dots,\cvar_k:=t_k]$,
    %   $\delta' = [\vec{\bvar}:=\vec{q}]$ and
    %   $\eta' = [\cvar_1:=u_1,\dots,\cvar_k:=u_k]$.
    %   All three substitutions have a domain $\subseteq \V$, and for all variables
    %   $a \in \FV(w)$ we have $\subrel{\gamma'(a),\delta',\eta'(a)}$.
    %   \begin{itemize}
    %   \item If $a = \cvar_i$ with $i$ maximal, then $\gamma'(a) =
    %     t_i$ and $\eta'(a) = u_i$, so $\subrel{\gamma'(a),\delta',\eta'(a)}$.
    %   \item If $a \notin \{\cvar_1,\dots,\cvar_k\}$ then $\gamma'(a) = \eta'(a) =
    %     a$.  Note that $a \notin \domain(\delta')$, since $a \in \FV(w) \setminus
    %     \{\avar_1,\dots,\avar_k\} = \FV(\delta(\Avar))$, and by assumption
    %     $\bvar_1,\dots,\bvar_n \notin \FV(\delta(a))$.
    %     Hence, by Lemma~\ref{lem:substitutionrefl}, $\subrel{\gamma'(a),\delta',
    %     \eta'(a)}$. \\
    %   \end{itemize}
    %   We also have $\subrel{w,\gamma',t}$ and $\subrel{w,\eta',u}$.
    %   Hence, we can apply Lemma~\ref{lem:combinesubst:gammadeltalimited} to obtain
    %   $\subrel{t,\delta',u}$, so $\subrel{t,[\vec{\bvar}:=\vec{q}],u}$.  This is
    %   exactly what we need.
    %   \qedhere
    % \end{itemize}
\end{proof}

Finally, we combine all the above results to obtain the full result we want:

\begin{lemma}\label{lem:combinesubst}
Let $s,t$ be terms and let $\gamma,\delta,\eta$ be substitutions, such that:
\begin{itemize}
\item $\domain(\eta) \setminus \V = (\domain(\gamma) \cup \domain(\delta))
  \setminus \V$
\item $\subrel{\gamma(\avar),\delta,\eta(\avar)}$ for all $\avar \in \FV(s)
  \cup (\FMV(s) \cap \domain(\gamma))$
\item $\delta(\Avar) = \eta(\Avar)$ for all $\Avar \in (\FMV(s) \setminus
  (\V \cup \domain(\gamma))) \cap \domain(\delta)$
\item $\subrel{s,\gamma,t}$
\end{itemize}
Then there exists $u$ such that both $\subrel{t,\delta,u}$ and
$\subrel{s,\eta,u}$.
\end{lemma}

(Note that if $\subrel{\gamma,\delta,\eta}$, the first three requirements are
indeed satisfied.)

\begin{proof}
By induction on the size of $s$.
Mostly this is the same as the proof of Lemma~\ref{lem:combinesubst:allbound};
only the case with $s = \meta{\Avar}{s_1,\dots,s_k}$ and $\Avar \in \domain(
\gamma)$ is new.  Writing $\gamma(\Avar) = \abs{\avar_1 \dots \avar_k}{a}$ and
$\eta(\Avar) = \abs{\bvar_1 \cdots \bvar_k}{b}$, we have
$\subrel{a,[\vec{\avar}:=\vec{t}],t}$ (with $\subrel{s_i,\gamma,t_i}$), and use
the induction hypothesis to find $u_1,\dots,u_k$ such that both
$\subrel{t_i,\delta,u_i}$ and $\subrel{s_i,\eta,u_i}$.
Since $[\vec{\avar}:=\vec{t}]$ has only variables in its domain, we can use
Lemma~\ref{lem:combinesubst:allbound} to find $u$ such that both
$\subrel{t,\delta,u}$ and $\subrel{a,\delta^{\vec{\avar}:=\vec{u}},u}$.
Then by Lemma~\ref{lem:combinesubst:special} we have $\subrel{b,[\vec{\bvar}:=
\vec{u}],u}$, which provides $\subrel{s,\eta,u}$.
    % 
    % \begin{itemize}
    % \item If $s = \afun$ then $t = \afun$ and we are quickly done choosing
    %   $u = \afun$.
    % \item If $s = \avar$ then we can safely choose $u = \eta(\avar)$.
    % \item If $s = h(s_1,\dots,s_n)$ or $\tuple{s_1}{s_n}$ then we complete by
    %   induction (like in Lemma~\ref{lem:combinesubst:allbound}).
    % \item If $s = \meta{\Avar}{s_1,\dots,s_k}$ with $\Avar \notin \domain(\gamma)$
    %   and $\Avar \notin \domain(\delta)$, then note that $\Avar \notin
    %   \domain(\eta)$; by the induction hypothesis we find $u_i$ with $\subrel{s_i,
    %   \eta,u_i}$ and $\subrel{t_i,\delta,u_i}$ for all $i$ and we can choose
    %   $u := \meta{\Avar}{u_1,\dots,u_k}$.
    % \item If $s = \meta{\Avar}{s_1,\dots,s_k}$ with $\avar \notin \domain(\gamma)$
    %   but $\Avar \in \domain(\delta)$ then $t = \meta{\Avar}{t_1,\dots,t_k}$ and
    %   we can find $u_i$ with $\subrel{s_i,\eta,u_i}$ and $\subrel{t_i,\delta,u_i}$.
    %   Moreover, $\delta(\Avar) = \eta(\Avar)$.
    %   If $\delta(\Avar) = \abs{\avar_1 \cdots \avar_k}{q}$ then choose $u$ such
    %   that $\subrel{q,[\avar_1:=u_1,\dots,\avar_k:=u_k],u}$.  Then both
    %   $\subrel{s,\eta,u}$ and $\subrel{t,\delta,u}$.
    % \item If $s = \abs{\avar}{s'}$ then $t = \abs{\bvar}{t'}$ with $\bvar
    %   \notin \FV(\gamma(w))$ for any $w \in \FV(s) \cup \FMV(s)$, and
    %   $\subrel{s',\gamma^{\avar:=\bvar},t'}$.
    %   Let $\cvar$ be a variable of the same type as $\avar$, which does not occur
    %   in any $\delta(w)$ or $\eta(w)$ for variables or meta-variables $w$ in $s$ or
    %   $t$.
    %   Then $\gamma^{\avar:=\bvar},\delta^{\bvar:=\cvar}$ and $\eta^{\avar:=\cvar}$
    %   satisfy the requirement to apply the induction hypothesis:
    %   \begin{itemize}
    %   \item $\domain(\eta^{\avar:=\cvar}) \setminus \V =
    %     (\domain(\eta) \cup \{\avar\}) \setminus \V = \domain(\eta) \setminus \V =
    %     (\domain(\gamma) \cup \domain(\delta)) \setminus \V =
    %     (\domain(\gamma) \cup \{\avar\} \cup \domain(\delta) \cup \{\bvar\})
    %     \setminus \V =
    %     (\domain(\gamma^{\avar:=\bvar}) \cup \domain(\delta^{\bvar:=\cvar}))
    %     \setminus \V$
    %   \item $\subrel{\gamma^{\avar:=\bvar}(w),\delta^{\bvar:=\cvar},\eta^{\avar:=
    %     \cvar}(w)}$ for all $w \in \FV(s') \cup (\FMV(s') \cap \domain(\gamma^{
    %     \avar:=\bvar}))$:
    %     \begin{itemize}
    %     \item if $w = \avar$, then indeed $\subrel{\bvar,\delta^{\bvar:=\cvar},
    %       \cvar}$
    %     \item if not, $\gamma^{\avar:=\bvar}(w) = \gamma(w)$ and $w \in \FV(s) \cup
    %       (\FMV(s) \cap \domain(\gamma))$. Since $w \in \FV(s') \setminus \{\avar\}$
    %       we have $w \in \FV(s)$, so $\bvar \notin \FV(\gamma(w))$.
    %       Hence, by Lemma~\ref{lem:substextend},
    %       $\subrel{\gamma(w),\delta,\eta(w)}$ implies $\subrel{\gamma(w),
    %       \delta^{\bvar:=\cvar},\eta(w)}$.  This suffices because
    %       $\eta(w) = \eta^{\avar:=\cvar}(w)$.
    %     \end{itemize}
    %   \item for meta-variables $\Avar$, $\delta^{\bvar:=\cvar}(\Avar) =
    %     \delta(\Avar)$ and $\eta^{\avar:=\cvar}(\Avar) = \eta(\Avar)$, so the
    %     third requirement is still satisfied
    %   \item $\subrel{s',\gamma^{\avar:=\bvar},t'}$ is given. \\
    %   \end{itemize}
    %   Hence, we find $u'$ such that both $\subrel{t',\delta^{\bvar:=\cvar},u'}$
    %   and $\subrel{s',\eta^{\avar:=\cvar},u'}$.  We are done choosing
    %   $u = \abs{\cvar}{u'}$.
    % \item This leaves only the case $s = \meta{\Avar}{s_1,\dots,s_k}$ with
    %   $\Avar \in \domain(\gamma)$; let $\gamma(\Avar) = \abs{\avar_1 \dots
    %   \avar_k}{a}$.  We make a number of observations.
    %   \begin{enumerate}
    %   \item\label{obs:stot}
    %     there exist $t_1,\dots,t_k$ such that
    %     $\subrel{s_i,\gamma,t_i}$ for all $i$, and
    %     $\subrel{a,[\avar_1:=t_1,\dots,\avar_k:=t_k],t}$
    %   \item\label{obs:stoui}
    %     there exist $u_1,\dots,u_k$ such that both
    %     $\subrel{t_i,\delta,u_i}$ and $\subrel{s_i,\eta,u_i}$ for all $i$
    %     \\ (by the induction hypothesis and \ref{obs:stot})
    %   \item\label{obs:etaX}
    %     we can write $\eta(\Avar) = \abs{\bvar_1 \dots \bvar_k}{b}$ with
    %     $\subrel{a,\delta^{\avar_1:=\bvar_1,\dots,\avar_k:=\bvar_k},b}$
    %     \\ (by Lemma~\ref{lem:abssubst} because $\subrel{\gamma(\Avar),\delta,
    %     \eta(\Avar)}$)
    %   \item\label{obs:bvari}
    %     each $\bvar_i \notin \FV(\delta(\cvar))$ for any $(\cvar \in \FV(a)
    %     \setminus \{\avar_1,\dots,\avar_k\}) \cup (\FMV(a) \cap \domain(\delta))$
    %     \\ (also by Lemma~\ref{lem:abssubst})
    %   \item\label{obs:bvarequal} if $\bvar_i = \bvar_j$ for some $i < j$ then
    %     $\avar_i \notin \FV(a)$ or $\avar_i = \avar_l$ for some $l > i$
    %     \\ (also by Lemma~\ref{lem:abssubst})
    %   \end{enumerate}
    %   Define $\delta_{\setminus\{\vec{\avar}\}} =
    %   [\bvar:=\delta(\bvar) \mid \bvar \in \domain(\delta) \setminus
    %   \{\avar_1,\dots,\avar_k \}]$ and $\delta^{\vec{\avar}:=\vec{u}} :=
    %   [\avar_1:=u_1,\dots,\avar_k:=u_k] \cup \delta_{\setminus\{\vec{\avar}\}}$.
    %   Then by (\ref{obs:stoui}) we have
    %   $\subrel{[\avar_1:=t_1,\dots,\avar_k:=t_k],\delta,\delta^{\vec{\avar}:=
    %   \vec{u}}}$.  By (\ref{obs:stot}) and
    %   Lemma~\ref{lem:combinesubst:allbound} we obtain that some $u$ exists such that
    %   both $\subrel{t,\delta,u}$, and $\subrel{a,\delta^{\vec{\avar}:=\vec{u}},u}$.
    %   Note that
    %   $\delta^{\vec{\avar}:=\vec{\bvar}} = [\avar_1:=\bvar_1,\dots,\avar_k:=\bvar_k]$
    %   and $\delta^{\vec{\avar}:=\vec{u}} = [\avar_1:=u_1,\dots,\avar_k:=u_k]
    %   \cup \delta_{\setminus\{\vec{\avar}\}}$, and that by
    %   (\ref{obs:etaX}--\ref{obs:bvarequal}), the conditions to apply
    %   Lemma~\ref{lem:combinesubst:special} are satisfied.  Hence, we find
    %   $\subrel{b,[\bvar_1:=u_1,\dots,\bvar_k:=u_k],u}$.
    %   This immediately provides $\subrel{s,\eta,u}$ as well.
    %   \qedhere
    % \end{itemize}
\end{proof}

Hence we may conclude the $=_\alpha$-sensitive version:

\begin{lemma}\label{lem:combinesubst}
Always $s(\gamma\delta) =_\alpha (s\gamma)\delta$.
\end{lemma}

\begin{proof}
Let $\eta$ be any substitution such that $\subrel{\gamma,\delta,\eta}$.
If $\subrel{s,\gamma,t}$ and $\subrel{t,\delta,a}$ and $\subrel{s,\eta,b}$,
then note that by Lemma~\ref{lem:combinesubst} there exists $u$ such that both
$\subrel{t,\delta,u}$ and $\subrel{s,\eta,u}$.  By
Lemma~\ref{lem:substitutionalpha}, $a =_\alpha u =_\alpha b$, so we conclude
$a =_\alpha b$ by Lemma~\ref{lem:alphaequiv}(\ref{lem:alphaequiv:transitive}).
\end{proof}

\end{document}

